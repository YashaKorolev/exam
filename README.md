# exam
Подготовка к экзамену по предмету "Алгоритмические языки" 2020
=====================
#### 1. Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
---
![list](https://prog-cpp.ru/wp-content/uploads/2014/04/DLS-add.png)

- O(1) - одна операция для всех возможных входных данных
- O(n) - операция на каждый элемент (цикл)
- O(n^2) - сложность порядка n квадрат (цикл в цикле)
- O(log n) - как будто массив у нас отсортирован ( в отличие от предыдущих, где худший вариант)

Каждый узел двунаправленого линейного списка содержит два поля указателей-
на следующий и предыдущий узлы. УКазатель на предыдущий узел для начального равен NULL.
УКазатель на следующий для конечного -  NULL.

##### В общем виде узел выглядит:
```cpp
struct list
{
    int field; // поле данных
    struct list* next; // указатель на следующий элемент
    struct list* prev; // указатель на предыдущий элемент
};
```
##### Основные действия, проводимые над узлами:
- инициализация списка
- добавление узла в список
- удаление узла из списка
- удаление корня
- вывод элементов
- вывод жлементов в обратном порядке
- взаимообмен двух элементов списка

##### Инициализация списка предназначена дял создания корневого узла списка, у которого поля указателей
на следующие и предыдущий узлы содержат нулевое значение.
```cpp
struct list * init (int a) // а - значение первого узла
{
    struct list *lst;
    lst = (struct list*)malloc(sizeof(struct list)); //выделение памяти
    lst -> field = a;
    lst -> next = NULL; //указатель на следующий элемент (его нет)
    lst -> prev = NULL; //указатель на предыдущий элемент (его нет)
    return(lst);
}
```
##### Функция добавления узла принимает:
- данные о добавляемом элементе
- указатель на узел, после которого происходит добавление
##### Само добавление включает в себя:
- создание узла и заполнение его данных
- изменение указателей элементов, соседних с новым
- функция выводит адрес добавляемого узла
```cpp
strust list * addlem (list *lst, int number)
{
    strust list *temp;
    temp = (struct list*)malloc(sizeof(list)); // выделение памяти
    strust list *p;

    p = lst->next; //сохраение указателя на следующий узел
    lst->next = temp; // предыдущий узел указывает на вставляемый
    temp->field = number;
    temp->next = p;
    temp->prev = lst;

    if (p != NULL)
      p->prev = temp;
    return (temp);
}
```
##### Удаление элемента списка
В качестве аргументов передается указатель на удаляемый узел.
Происходит обмен указателями и функция возвращает указатель на узел,
следующий за удаляемым.
```cpp
strust list * delete (list*lst)
{
    struct list *prev;
    struct list *next;
    prev = lst->prev;
    next = lst->next;
    if (prev != NULL)
        prev->next = lst->next;
    if (next != NULL)
        next->prev = lst->prev;
    return (prev);
}
```
##### Поиск элемента с определенным значением
В функцию передается указатель на корень списка и значение элемента,
который нам нужно найти.
```cpp
bool search(list *lst, int number)
{
  struct list *p;
  p = lst;

  while (p != NULL)
  {
    if (p->field == number)
        return true
    p = p->next;
  }
  return false;
}
```
##### Оценки сложности (N - размер контейнера/количество элементов):
- Вставка/удаление - O(1)
- Поиск элемента - O(N)
##### LIST
Этот контейнер быстро добавляет и удаляет значения, потому что не пприходится
перемещать элементы между собой, а нужно только грамотно манипулировать
указателями.

##### Этот контейнер находится в библиотеке:
```cpp
#include <list>
```
##### Cоздание:
```cpp
list <тип данных> имя контейнера = { список, аргументов};
```
##### Основные методы:
- emplace/push_front (создает(без лишнего копирования)/копирует(перемещает) элемент в начало списка)
- emplace/push_back (создает/копирует(перемещает) элемент в конец списка)
- emplace/insert (создает/копирует(перемещает) элемент в указанную позицию)
- pop_back, pop_front, erase, clear (удаление с конца, с начала, удаление с известной позиции или промежутка, удаление всех элментов(size = 0))
- swap (Обменивает содержимое контейнера с контейнером x)
- front, back (обратиться к первому и последнему элементу)
##### Основные операции:
- remove - удаляет элементы сравнимые с передаваемым значением (то есть по значение, а не по позиции)
- sort - сортирует элементы списка (по умолчанию в порядке возрастания)
- reverse - меняет порядок элементов в списке на противоположный
- merge - слияние двух отсортированных списков, второй список остается пустым.
- splice - переносит элементы из одного списка в другой с указанной позиции (второй список становиться пустым)
Копирование не происходит.

```cpp
#include <iostream>
#include <list>
int main() {
    std::list<int> mylist1 = {1,2,3,4};
    std::list<int> mylist2 = {10,20,30};

    auto it = mylist1.begin();
    ++it;
    mylist1.splice (it, mylist2);
    // mylist1 1 10 20 30 2 3 4
    // mylist2 (empty)
    // "it" still points to 2 (the 5th element)

    mylist1.erase(mylist1.begin()); //mylist1 10 20 30 2 3 4

    mylist2.push_back(23); //mylist2 23
    mylist2.push_back(23); //mylist2 23 23

    mylist2.swap(mylist1); //mylist2 10 20 30 2 3 4  mylist1 23 23

    mylist2.sort(); //mylist2 2 3 4 10 20 30
}
```

#### 2. Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
---
![map](https://qph.fs.quoracdn.net/main-qimg-12cd34c071b5ed07220d841c3c0b2090)

Отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде красно-черных деревьев.

Красно-черное дерево - это бинарное дерево поиска с дополнительным параметром цветом в каждом узле. В соответствии с накладываемыми на узлы дерева ограничения ни один простой путь от корня в КЧД не отличается от другого по длине более чем в два раза, таким образом КЧД являются приближенно сбалансированными.
Значения могут быть получены непосредственно по ключу с помощью оператора [].
При добавлении нового элемента контейнер будет отсортирован по возрастанию.

##### Map находится в библиотеке:
```cpp
#include <map>
```
##### Cоздание map:
```cpp
map <тип данных ключа, тип данных значени> имя;
```
При создании map все его элементы будут иметь значение нуля или сразу инициализированы.
```cpp
map <string, string> pair = {{Alena, Taehyung}, {JK, Te}};
```
##### Основные методы:
- insert - вставка элемента/элементов. В последнем случае сложность O(N * log(size + N)). Поскольку ключи элемента в карте уникальны, операция вставки проверяет, есть ли у каждого вставленного элемента ключ, эквивалентный ключу элемента, уже находящегося в контейнере, и, если это так, элемент не вставляется, возвращая итератор.
```cpp
std::map<char,int> mymap;
// first insert function version (single parameter):
mymap.insert ( std::pair<char,int>('a',100) );
mymap.insert ( std::pair<char,int>('z',200) );

std::pair<std::map<char,int>::iterator,bool> ret;
ret = mymap.insert ( std::pair<char,int>('z',500) );
if (ret.second==false) {
    std::cout << "element 'z' already existed";
    std::cout << " with a value of " << ret.first->second << '\n';
}

// second insert function version (with hint position):
std::map<char,int>::iterator it = mymap.begin();
mymap.insert (it, std::pair<char,int>('b',300));  // max efficiency inserting
mymap.insert (it, std::pair<char,int>('c',400));  // no max efficiency inserting

// third insert function version (range insertion):
std::map<char,int> anothermap;
anothermap.insert(mymap.begin(),mymap.find('c'));
// mymap contains [a,100], [b, 300], [c, 400], [z, 200] anothermap contains [a,100], [b,300]
```

- emplace - Вставляет новый элемент в карту, если его ключ уникален. Этот новый элемент создается на месте, а не копируется или перемещается.
```cpp
std::map<char, int> mymap;
mymap.emplace('a', 1);
mymap.emplace('b', 2);
```
- erase - удаление элемента по ключу, по итератору или в диапозоне.
```cpp
std::map<char, int> mymap;
mymap['a'] = 1;
mymap['b'] = 2;
mymap.erase('a');
```
- swap - обменивает содержимое контейнера на содержимое x , который является другой картой того же типа. Размеры могут отличаться.
- clear - удаление всех элементов из карты.
- find - ищет в контейнере элемент с указанным ключем, возвращает итератор на найденный элемент. (Если ключа нет возвращает end())

##### Оценка сложности:
- Вставка/удаление - O(log N)
- Поиск элемента по ключу - O(log N)

#### 3. Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
---
![set](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)

std::set - множество. Элементы уникальны, а так же сравниваются и сортируются при добавлении по возрастанию. Чаще всего реализовано так же как и std::map с помощью красно-черных деревьев.
##### Библиотека и создание:
```cpp
#include <set>

set <тип> имя{2,3,4};
```

##### Основные методы:
- insert
- erase (удаляет элемент (по итератору), все элементы по значению или диапазон элементов)
- swap
- clear
- emplace
- find (поиск элемента по значению. выводит: местонахождение(итератор) или значение на конец контейнера)
- lower_bound / upper_bound (находит элемент >= ключу / находит элемент > ключа)
```cpp
имя.lower_bound(key);
```
Сложность такая же как и у std::map в силу использования одинаковой структуры данных

###### Пример работы:
```cpp
    std::set<int> myset;
    std::set<int>::iterator it;
    std::pair<std::set<int>::iterator,bool> ret;

    // set some initial values:
    for (int i=1; i<=5; ++i)
        myset.insert(i*10);    // set: 10 20 30 40 50

    ret = myset.insert(20);               // no new element inserted

    if (ret.second==false)
        it=ret.first;  // "it" now points to element 20

    myset.insert (it,25);

    int myints[]= {5,10,15};              // 10 already in set, not inserted
    myset.insert (myints,myints+3);       // myset: 5 10 15 20 25 30 40 50

    myset.erase(10); // myset: 5 15 20 25 30 50
    it = myset.begin();
    it++;

    myset.erase(it); // myset: 5 20 25 30 50
    it = myset.find(25);
    myset.erase(it, myset.end()); // myset: 5 20

    std::set<int> myset2 {1, 2, 3};
    myset2.emplace(4);

    myset1.swap(myset2)
 for (auto& x:mymap)
   std::cout << x.first << " " << x.second;
```

#### 4. Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
---
unordered_map - является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время.
Внутренне unordered_map реализована с использованием хэш-таблицы, ключ хэшируется в индексы хэш-таблицы, поэтому производительность структуры данных во многом зависит от хэш-функции, но в среднем вставка и удаление из хэш-таблицы составляет О(1).
Неупорядоченные контейнеры реализуют оператор прямого доступа[], который позволяет осуществлять прямой доступ к значению, использую его ключв качестве аргументов. Никакие два элемента не могу иметь эквивалентные ключи.
![hash_table](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png)

### Начало работы
```cpp
#include <unordered_map>

std::unordered_map <тип ключа, тип значения> имя;
имя[ключ]= значение;

 //или сразу

std::unordered_map <bool, int> mymap2 = { {true, 4}, {false, 43}};
```
##### Основные методы:
- emplace
- emplace_hint (возможно вставить в определенную позицию)
```cpp
unordered_map.emplace_hint(позиция, клюс, значение)
```
- insert
- erase (удаляет из контейнера один или несколько элементов)
- clear (зачищает контейнер)
- swap (обменивается сожержимым)
- find (возвращает итератор на найденный элемент или итератор на конец контейнера)

Можно вывести непосредственно ключ и значение:
```cpp
std::cout <<got->first << "is" << got->second; // got - итератор на пару
```

##### Пример
```cpp
#include <iostream>
#include <unordered_map>
int main()
{
    std::unordered_map <bool, int> mymap;
    mymap[false]=3;
    mymap[true] = 17;

   mymap.insert(std::make_pair<bool,int> (false, 4));

   std::unordered_map <bool, int> mymap2;
       mymap[false]=43;
       mymap[true] = 54;

   mymap.insert(mymap2.begin(), mymap2.end());

   mymap.swap(mymap2);

   mymap2.erase (false);

   mymap.erase(mymap.begin());

   mymap2.emplace(false, 83);

   mymap2.erase(mymap2.begin(), mymap2.end()); //удаление с позиции по позицию (не включительно)

   for (auto& x:mymap)
   std::cout << x.first << " " << x.second;
}
```
#### 5. Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
---
std :: vector - динамический массив. Как и массивы, используются последовательные участки памяти для своих элементов. Размер может изменяться автоматически, а размер автоматически обрабатывается контейнером.
![vector](https://qph.fs.quoracdn.net/main-qimg-d2696c877d001f9e11c316bc1c5412ac)
##### Начало работы
```cpp
#include <vector>

vector <тип данных> имя = { 2,4,4};

vector <тип данных> имя(количество ячеек);

vector <тип данных> имя;
имя.reserve(количество ячеек);
```
##### Обращение к элементу
```cpp
#include <vector>

vector <int> my = { 2,4,5};
int a = my[1]; // a = 4
int b = my.at(2); //b = 5.  Проверяет находится ли n в пределах допустимых элементов в векторе, выбрасывая out_of_range, [] не проверяют
```
##### Основные методы:
- emplace - создание и вставка элемента на заданную позицию (О(n)).
- emplace_back - создание и вставка в конец (O(1)).
- push_back - вставка элемента в конец (О(1)).
- insert - вставка элемента в указанную позицию(если указан итератор, то после той ячейки, на которую он указывает) (O(n)). НЕ очень эффективна, так как приходится перемещать все элементы после той позиции на их новые позиции.
- swap - обмен содержимым с другим вектором (О(n)).
- erase - удаление элемента с указанной позиции или элементов из диапазона (O(n)).
- clear - удаление всех элементов вектора (O(n)).
- size - возвращает размер вектора (O(n)).
- resize - изменяет размер вектора (O(n)). Удаляет элементы лишние или добавляет те, что указаны (автоматически 0)
- capacity - возвращает количество элементов, на которые хватит зарезервированной памяти.
- reserve - резервирует области памяти для указанного количества элементов.
- assign - заменяет текущее значение вектора на введенное (изменяя размер вектора)

##### Пример
```cpp
#include <iostream>
#include <vector>

int main(){
    std::vector<int> my;

    for(size_t i = 0; i<10; ++i)
        my.push_back(i);

    my.erase(my.begin()+5); // удаление шестого элемента
    my.erase(my.begin(), my.begin()+3); //удаление первых трех элементов

    my.insert(my.begin(), 43);

    my.resize(5);

    std::vector<int> my2 = { 2,4,5};
    my2.swap(my);

    for ( size_t i = 0; i<my.size(); ++i)
        std::cout << my.at(i);
}
```
##### Особенности std::vector<bool>:
Cпециализация std::vector, более эффективно использующая память путем храненения булевых значений в каждом бите (в обычном векторе резервируется для одного элемента минмум 1 байт, а в этом 1 битом, то есть меньше в 8 раз). Так же предоставляет особый метод - flip, для инвертирования всех значений массива.
Все экземпляры true становятся false и наоборот.

```cpp
std::vector <bool> my;
my.flip();
```
#### 6. Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
---
ООП(объектно-ориентированное программирование) - методология программирования, в которой основными концепциями являются понятия объектов и классов. Парадигмы ООП: полиморфизм, наследование и инкапсуляция.

_Инкапсуляция_ - сокрытие информации, которое гарантирует что данные объекта и его методы используются по назначению. Использование инкапсуляции позволяет в дальнейшем изменять устройство классов без вреда для пользователя, при условии что открытый интерфейс объекта остается неизменным. С++ предоставляет 3 типа доступа - public, protected(доступ открыт классам, производным от данного) и private(только для функций класса или для друзей класса).

_Наследование_ - базирование одного типа данных (объекта или класса) на другом типе данных, способствующее повторному использованию уже существующего кода. Помимо повторного использования кода через наследование реализуются очевидные связи между классами, что способствует чистоте кода. С++ предлагает несколько типов наследования - public, protected, private и даже виртуальное наследование, каждое из которых реализует определенное отношение между классами.
![prim](https://codelessons.ru/wp-content/uploads/%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-c-1.png)

Если наследование public - использовать можно public и protected родительского класса.
Если наследование protected - пользовательсяяяя можно только свойствами (не функциями) родителя.
Чтобы использовать функции нужно разрешить это напрямую (и без круглых скобок, только имя),
а также разрешить нужно в публичном доступе (public).
```cpp

class Animals {
  public:
    int counter;  // общее кол животных
  protected:
    int zebras;
    int bears;
    int dogs;

    // функция вычисление общего количества животных
    count_animals() {
      counter = dogs + bears + zebras;
    }
    set_dogs(int count_of_dogs) {
      dogs = count_of_dogs;
    }
};

class Dog : private Animals {
  public:
    int count_dogs() {
      return dogs;  // использовали переменную dog
    }
    Animals :: set_dogs;

};

int main() {
    Dog jack;
    int k;
    cout << "Введите количество собак: "; cin >> k;

    jack.set_dogs(k);
    cout << "Количество собак равняется: "<< jack.count_dogs();
    return 0;
}
```
Модификатор наследования →	public	      private	  protected
Модификатор доступа ↓
 public	                    public	      public	 protected
 private	             нет доступа	нет доступа	 нет доступа
 protected	               protected	 protected	  protected

_Полиморфизм_ - cвойство, которое позволяет использовать одно и тоже имя функции
для решения двух и более схожих, но технически разных задач.
С++ допускае два типа полиморфизма: cтатический и динамический

_Статический полиморфизм_ представлен перегрузкой функций, аргументами по умолчанию и шаблонами. Таким образом функция ведет себя по разному в зависимости от параметров или типа, над которыми она работает.
_Динамический полиморфизм_ представлен наследованием и виртуальными функциями. Во время выполнения определяется какой метод необходимо использовать для соответствующего объекта в иерархии.
_Суть статического связывания:_ когда указатель одного типа ссылается на объект другого типа при наследовании классов, то выбор переопределенного метода определяется типом указателя, а не типом объекта.
_Суть динамического связывания:_ когда указатель одного типа ссылается на объект другого типа при наследовании классов, то выбор переопределенного метода определяется типом объекта, а не типом указателя, для этого переопределенный метод должен быть объявлен виртуальным в базовом классе.
###### Пример статического
![prim3](https://sun9-53.userapi.com/c204520/v204520534/368dd/CRm_JSE80OA.jpg)
##### Пример динамического
![prim4](https://sun9-20.userapi.com/c204520/v204520534/368e4/ygIhBNXfGnU.jpg)
#### 7. Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
---
##### Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
Явное инстанцирование:
```cpp
std::cout  << function <double> (-2,4);
```
Оно используется:
- если инстанцирование шаблонов занимает слишком много времени
- если порядок компиляции должен быть абсолютно предсказуем

Неявное инстанцирование:
```cpp
std::cout  << function (-2,4);
```
##### Версия шаблона для конкретного аргумента шаблона называется специализацией.
Специализация - ручное указание реализации сущности для каких-либо конкретных параметров. Может быть полной или частичной.
```cpp
// Сама шаблонная функция. На ее месте может быть и класс
template <typename T1, typename T2>
void foo() {}

// Полная специализация
template <>
void foo<int, int>() {}

// Частичная специализация
template <typename T>
void foo<int, T>() {}
```
Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа. Любой шаблон начинается со слова template. После ключевого слова template идут угловые скобки — < >, в которых перечисляется список параметров шаблона. Каждому параметру должно предшествовать зарезервированное слово class или typename. . Некоторые примеры объявления шаблонов:
```cpp
template <class T> или template <typename T> или template <typename T1, typename T2>
```
Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных, такой как: int, double,float, char и т. д. А ключевое слово class сообщает компилятору, что в шаблоне функции в качестве параметра будут использоваться пользовательские типы данных, то есть классы. Но не в коем случае не путайте параметр шаблона и шаблон класса. Если нам надо создать шаблон класса, с одним параметром типа int и char, шаблон класса будет выглядеть так:
```cpp
template <typename T>

class Name

{
//тело шаблона класса
};
```
где T — это параметр шаблона класса, который может принимать любой из встроенных типов данных, то, что нам и нужно.

А если параметр шаблона класса должен пользовательского типа, например типа Array, где Array — это класс, описывающий массив, шаблон класса будет иметь следующий вид:
```cpp
template <class T>
class Name
{
//тело шаблона класса
}
```
##### Пример
```cpp
#include <iostream>

using namespace std;

template < class T>

class
private:
    T a1[size];

public:
    Te()
    {
    for (int i=0; i < size; i++)
    {
    cout << endl << "Vvedite " << i + 1 << " chislo ";
    cin >> a1[i];
    }
}
void slog()
{
    for (int i=0; i < size-1; i++)

    {
    a1[0] = a1[0] + a1[i + 1];
    }
    cout << endl << "Rezyltat clogenia= " << a1[0];
}
};
int main()
{
    Te <int> F;
    F.slog();
    cout << endl;
}
```
#### 8. Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
---
Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов очень удобно перебирать элементы. Итератор описывается типом iterator. Но для каждого контейнера конкретный тип итератора будет отличаться. Так, итератор для контейнера list<int> представляет тип list<int>::iterator, а итератор контейнера vector<int> представляет тип vector<int>::iterator и так далее.
Итератор - это не указатель.
##### Преимущества:
- Удобство в программировани (не нужно заранее знать количество элементов в контейнере)
- Динамическая обработка контейнера. Очень удобно добавлять или удалять элементы из контейнера
в любое время.

Начало работы:
 ```cpp
 #include <iterator>

 контейнер <его тип> :: iterator имя;
 ```
 ##### Виды итераторов
 - container::iterator (итератор для чтения/записи)
 - container::const_iterator (итератор только для чтения)

 Можно сразу  пределить, на что итератор будет указывать.
  ```cpp
 vector <int> my;
 vector <int> :: iterator it = my.begin();
  ```
Для получения итераторов контейнеры в C++ обладают такими функциями, как begin() и end(). Функция begin() возвращает итератор, который указывает на первый элемент контейнера (при наличии в контейнере элементов). Функция end() возвращает итератор, который указывает на следующую позицию после последнего элемента, то есть по сути на конец контейнера. Если контейнер пуст, то итераторы, возвращаемые обоими методами begin и end совпадают. Если итератор begin не равен итератору end, то между ними есть как минимум один элемент.

С итераторами можно проводить следующие операции:
- *iter: получение элемента, на который указывает итератор
- ++iter: перемещение итератора вперед для обращения к следующему элементу
- --iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
- iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
- iter1 != iter2: два итератора не равны, если они указывают на разные элементы _Если вы создали два одинаковых итератора на map, то при сравнивании они не будут одинаковыми_
- iter += 5 различные арифметические операции (*, /, +, -) НЕ РАБОТАЕТ С _list_ , _set_ , _map_ , НО работает с _vector_

##### Функция advance()
Перемещает итератор, передаваемый ей в качестве аргумента.
```cpp
advance(итератор, диапозон)
```
Диапазон может быть как отрицательным (-6), так и положительным (6), в зависимости от этого
итератор будет двигаться вперед или назад.

```cpp
#include <iostream>
#include <iterator>
#include <vector>
int main()
{
    std::vector<int> v{ 3, 1, 4 };

    auto vi = v.begin();

    std::advance(vi, 2);

    std::cout << *vi << '\n';  // 4
}
```
_Итераторы ввода_ - итераторы, который перемещается только в одном направлении и поддерживает только чтение.
Это итераторы, которые можно использовать в последовательных операциях ввода, где каждое значение, указанное итератором, читается только один раз, а затем увеличивается итератор.
##### Плюсы
- Удобство использования: входные итераторы могут использоваться только с однопроходными алгоритмами
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый: Итератор ввода может быть увеличен, так что он ссылается на следующий элемент в последовательности, используя оператор ++ ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.

##### Минусы
- Мы не можем присвоить какое-либо значение местоположению, указанному этим итератором, оно может использоваться только для доступа к элементам, а не для назначения элементов
- Невозможно уменьшить: мы не можем использовать operator -- ()
- Невозможно использовать в алгоритмах, где нужно обрабатывать контейнер несколько раз
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> v1 = { 1, 2, 3, 4, 5 };
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Доступ к элементам с помощью итератора
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Итераторы вывода_ - итераторы, допускающие запись и единичный проход в одном направлении. Им могут быть назначены значения в последовательности , но они не могут использоваться для доступа к значениям, в отличие от входных итераторов, которые делают обратный доступ к значениям и не могут быть назначены значения.
_Плюсы те же, что у итераторов ввода_
##### Минусы
- Только присваивание, без доступа: один из самых больших недостатков в том, что мы не можем получить доступ к выходным итераторам как rvalue. Таким образом, выходной итератор может изменять только тот элемент, на который он указывает, будучи использованным в качестве цели для назначения
- Все, кроме первого у итераторов ввода
```cpp
// C ++ программа для демонстрации выходного итератора
#include<iostream>
#include<vector>
using namespace std;
int main()

{
    vector<int>v1 = {1, 2, 3, 4, 5};
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1=v1.begin();i1!=v1.end();++i1)
    {
        // Назначение элементов с помощью итератора
        *i1 = 1;
    }
    // v1 становится 1 1 1 1 1
    return 0;
}
```
_Итераторы прямого доступа_ - итератор, дополнительно к свойствам предыдущих двух, допускающий множественный проход в одном направлении.
##### Плюсы
- Удобство использования: выполнение операций на прямом итераторе с разыменованием никогда не делает его значение итератора неотменяемым, в результате это позволяет алгоритмам, использующим эту категорию итераторов, использовать несколько копий итератора для многократной передачи одних и тех же значений итератора. Таким образом, его можно использовать в многопроходных алгоритмах .
- Остальные как у итераторов ввода (без первого)
##### Минусы
- Невозможно уменьшить: мы не можем использовать operator -- ()
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.
```cpp
// C ++ программа для демонстрации прямого итератора
#include <iostream>
#include <vector>

using namespace std;
int main()
{
    vector<int> v1 = { 1, 2, 3, 4, 5 };
    // Объявление итератора
    vector<int>::iterator i1;
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Присваиваем значения местам, указанным итератором
        *i1 = 1;
    }
    for (i1 = v1.begin(); i1 != v1.end(); ++i1) {
        // Доступ к значениям в местах, указанных итератором
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Двунаправленные итераторы_ - итератор, допускающий проход в обоих направлениях.
##### Плюсы
- Удобство использования: Поскольку итераторы прямого преобразования могут использоваться в многопроходных алгоритмах, т. Е. Алгоритме, который включает обработку контейнера несколько раз за различные проходы, поэтому двунаправленные итераторы также могут использоваться в многопроходных алгоритмах.
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый и Уменьшаемый: Итератор ввода может быть увеличен, уменьшен, используя оператор ++ () или -- ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.

##### Минусы
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.

```cpp
// C ++ программа для демонстрации двунаправленного итератора
#include<iostream>
#include<list>

using namespace std;

int main()

{
    list<int>v1 = {1, 2, 3, 4, 5};
    // Объявление итератора
    list<int>::iterator i1;
    for (i1=v1.begin();i1!=v1.end();++i1)
    {

        // Присваиваем значения местам, указанным итератором
        *i1 = 1;
    }
    for (i1=v1.begin();i1!=v1.end();++i1)
    {
        // Доступ к значениям в местах, указанных итератором
        cout << (*i1) << " ";
    }
    return 0;
}
```
_Итератор произвольного доступа_ - итератор, допускающий произвольный доступ .
##### Плюсы
- Удобство использования: итераторы с произвольным доступом могут использоваться в многопроходных алгоритмах , т.е. алгоритме, который включает обработку контейнера несколько раз за различные проходы.
- Сравнение равенства / неравенства: входной итератор можно сравнить на равенство с другим итератором.
- Разыменование: Итератор ввода может быть разыменован, используя операторы * и -> в качестве значения r, чтобы получить значение, сохраненное в позиции, на которую указывает итератор
- Увеличиваемый и Уменьшаемый: Итератор ввода может быть увеличен, уменьшен, используя оператор ++ () или -- ().
- Swappable: значение, на которое указывают эти итераторы, можно заменить или обменять.
- Нельзя использовать арифметические операции
- Реляционные операторы: хотя входные итераторы могут использоваться с оператором равенства (==), но его нельзя использовать с другими реляционными операторами, такими как, <=.
- Использование оператора разыменования смещения ([]): прямые итераторы не поддерживают оператор разыменования смещения ([]), который используется для произвольного доступа.

```cpp
// C ++ программа для демонстрации итератора с произвольным доступом
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    vector<int>v1 = {1, 2, 3, 4, 5};

    int i;
    // Доступ к элементам с использованием разыменования смещения
    // оператор []
    for(i=0;i<5;++i)
    {
        cout << v1[i] << " ";
    }
    return 0;
}
```
![iterators](https://github.com/sergejkoll/exam-preparation/blob/master/images/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-01-06%2013-25-01.png)
#### 9. Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
---
_auto_ - До С++11 ключевое слово использовалось для явного указания, что переменная должна иметь автоматическую продолжителность (создаваться в точке определения и уничтожаться в конце блока, в котором определена) Но, поскольку все переменные в новых версиях С++ по умолчанию умеют автоматическую продолжительность, то слово устарело. В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения, так же  вы можете использовать auto вместо типа возвращаемого значения функции (но это очень опасно).
##### Примеры
```cpp
int subs(int a, int b)
{
    return b + a;
}

int main()
{
    auto result = subs(3,7); //функция вернет значение типа int и переменная тоже станет типа int
    return 0;
}
```
Переменные, объявленные без инициализации не могут использовать фичу, так как нет инициализируемого
значения и компилятор не может знать, какой тип данных присвоить переменной.
```cpp
void myswap(auto a, auto b)
{
    auto x = a;
    a=b;
    b=x;
}
```
Это не сработает, так как как компилятор не может определить типы данных для параметров функции a и b во время компиляции.

_decltype_ - проверяет объявленный тип объекта или тип выражения. Auto позволяет
вам объявлять переменную с определенным типом, тогда как decltype позволяет извлекать
тип из переменной, поэтому decltype является своего рода оператором, который оценивает
тип переданного выражения.

###### Пример
```cpp
int x = 5;
double y = 6.4;

decltype(x) foo; //int
decltype(y) foo; //double
decltype(x+y) foo; //double
```
_Range-based for loop_ - Выполняет цикл для диапазона. Используется в качестве более удобочитаемого эквивалента традиционному циклу for, работающему в диапазоне значений, таких как все элементы в контейнере.
##### Пример
```cpp
std::vector<int> v =  {0, 1, 2, 3, 4, 5};
for (auto i : v) // доступ по значению, тип i - int
    std::cout << i << ' ';
```
_nullptr_ - нулевое значение указателя (является константой r-value). Используется при работе с нулевыми укащателями, предпочтительнее, чем использование 0

```cpp
int *ptr = nullptr;
```
Можно использовать для вызова функции( в качестве аргумента - литерала)

```cpp
#include <iostream>

void do(int *ptr)
{
    if (ptr)
        std::cout<<"You passed in " << *ptr << "\n";
    else
         std::cout<<"You passed in a NULL pointer \n";
}

int main()
{
    do(nullptr); //теперь аргумент точно является нулевым указателем, а не целочисленным типом
}
```

В С++11 добавили тип данных std::nullptr_t, который находится в заголовочном файле <cstddef>.
Этот тип может принимать только значение nullptr, если полено, если вам нужно написать функцию, которая принимает аргумент nullptr.
_constexpr_ - спецификатор, который сообщает компилятору, что текущая переменная является константой времени компилации.
_Константы времени компиляции._ Их значения определяются во время компиляции программы. Например, переменная со значением силы тяжести на Земле является константой времени компиляции, так как мы её определяем во время написания программы (до начала её выполнения).
_Константы времени выполнения._ Их значения определяются только во время выполнения программы. Зависит от пользовательского ввода (который можно получить только во время выполнения программы) или зависит от значения, переданного в функцию (которое станет известным также во время выполнения программы).
##### Примеры
```cpp
constexpr int sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int c = sum (5, 12); // значение переменной будет посчитано на этапе компиляции
}
```
```cpp
struct A {
    constexpr static double x = 10.0;
    //const static double x = 10.0 - не скомпилируется
};

int main() {
    A a;
    return 0;
}
```
_enum_ (перечисление) - тип данных, где любое значение определяется как символьная константа.
При объявлении не выделяется память, а только после определения. Каждый перечислитель разделяется запятой,
а само перечисление заканчивается ;. Идентификаторы перечисления с большой буквы, а имена
перечислителей все большими буквами. Каждому перечислителю автоматически присваивается целочисленное значение
в зависимости от позиции в списке (от 0 и ++). Можно присвоить и свои значения, даже отрицательные (любые, не определенные
вами перечислители, будут иметь значения на единицу больше, чем значения предыдущих перечислителей),
но лучше не присваивать одинаковые, а лучше даже вообще свои не присваивать.
Поскольку значения перечислителей являются целые числа, то их можно присваивать целочисленным переменным, а также
выводит в консоль(как переменные int).
##### Пример
```cpp
#include <iostream>
enum Colors
{
    COLOR_PINK,    // 0
    COLOR_BROWN    // 1
};

int main()
{
    Colors color = 9; // ошибка. компилятор не будет неявно конвертировать целочисленное значение в значение перечислителя
    Colors color = stasic_cast<Colors>(9); // ошибки не будет но так делать не рекомендуется (явное преобразование типов)
    int my = COLOR_BROWN;
    std::cout << COLOR_BROWN; //конвертирует в int а затем выводится на экран
}
```
_enum class_ - перечисления с областью видимости, которые добавляют перечислениям локальную видимость со всеми ее правилами.
##### Пример
```cpp
#include <iostream>

int main(){
    enum class Fruits { //добавление class определяет перечесление с ограниченной областью видимости
        LEMON,//LEMON находтися внутри той же области видимости, что и FRUITS
        KIWI
    };

    enum class Colors {
        PINK,    //PINK находтися внутри той же области видимости, что и Colors
        GREY,
    };

    Fruits fruit = LEMON; //Lemon напрямую использовать нельзя, нужно использовать Fruits::LEMON
    Colors color = Colors::PINK;

    if(fruit == color) //ошибка, компилятор не знает, как сравнивать разные типы
    //если убрать class, то уже не будет ошибки в строчке с лимоном и со сравнением, а будет сравнивать эти переменные как целые числа
}
```
_if constexpr_ - if во время компиляции.
```cpp
template <typename T>
std::string str(T t) {
  if constexpr (std::is_same_v<T, std::string>) // строка или преобразуемый в строку
    return t;
  else
    return std::to_string(t);
}
```
Если использовать без constexpr, то компилятор выдаст ошибку, так как компилятор попытается
разобрать обе условные ветки и найдет ошибку в случае else. Он не сможет отбросить неправильный код.
Именно для этого и нужен constexpr, который будет исключать код и компилировать
только тот блок, который подходит условию.
#### 10. Современный С++: static_assert, initializer_list, default, final, override, using
---
_assert_ (или ещё «оператор проверочного утверждения») в C++ — это макрос препроцессора, который обрабатывает условное выражение во время выполнения.
Если условное выражение истинно, то ничего не происходит, если ложно, то выводится сообщение об
ошибке (содержит ложное условное выражение, имя файла и номер строки) и программа завершается.
Объявлен в заголовочном файле cassert.

_static_assert_ - во время компиляции. (Поскольку static_assert не обрабатывается во время компиляции, то стейтменты static_assert могут быть размещены в любом месте кода (даже в глобальном пространстве))
```cpp
static_assert(sizeof(long) == 234, "long must be 8 bytes"); // тут будет ошибка
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```
_initializer_list_ - список инициализации. Вы должны указать в угловых скобках, какой тип данных будете использовать
Имеется функция size(), которая возвращает количество элементов списка.
##### Пример
```cpp
#include <iostream>
#include <initializer_list>

class A
{
public:
    A(std::initializer_list<int> list)
    {
        for(auto& item : list)
        {
            std::cout << "item=" << item << "\n";
        }
    }
};

int main()
{
    A a{23,321,321,3,213,213,12};
};
```
 _default_ - суть спецификатора заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.(применим только к конструкторам (по умолчанию, копирования, перемещения), деструктору и оператору присваивания/перемещения)
##### Пример
```cpp
class Foo
{
public:
    Foo() = default; //конструктор по умолчанию
    Foo(const Foo&) = default; //конструктор копирования
    Foo(Foo&&) = default; //конструктор перемещения
    ~Foo() = default; //деструктор
    Foo& operator=(Foo&&) = default; //оператор присваивания перемещением
    Foo& operator=(const Foo&) = default; //оператор присваивания копированием
    Foo(int x) {/* ... */} //конструктор с 1 параметром не может быть default
};
```
_final_ - С++11 позволяет запрещать в классах-наследниках переопределение определенных методов. Достигается это за счет применения спецификатора final рядом с сигнатурой метода. Можно даже запретить наследование определенного класса.
##### Примеры
```cpp
class Base
{
public:
    virtual void doSomething(int x) final;
};
class Derived : public Base
{
public:
    virtual void doSomething(int x); // ошибка!
};

```
```cpp
class Base final
{
public:
    virtual void doSomething(int x) final;
};
class Derived : public Base // ошибка
{
public:
    virtual void doSomething(int x);
};
```
_override_ - если метод не переопределяет виртуальную функцию родительского класса, то кимпилятор выдаст
ошибку.
##### Пример
```cpp
class Base
{
public:
    virtual void doSomething(int x);
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(int x) override; //не ошибка
    virtual void doSomething(long x) override; //ошибка
};
```
_using_ - используется для создания псевдонимов типа данных.
##### Примеры
```cpp
using std::cout; //объявление сообщает компилятору, что cout следует обрабатывать как std::cout
using iterator = typename std::vector<value_type>::iterator;
using namespace std; // использование пространства имен std
```
#### 11. Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
---
Класс ```std::optional``` управляет опциональным значением, т. е. значением, которое может присутствовать или отсутствовать.
##### Создание
```cpp
// пустой:
std::optional<int> oEmpty;
std::optional<float> oFloat = std::nullopt;

// прямой:
std::optional<int> oInt(10);
std::optional oIntDeduced(10); // deduction guides

// make_optional
auto oDouble = std::make_optional(3.0);
auto oComplex = make_optional<std::complex<double>>(3.0, 4.0);

// in_place
std::optional<std::complex<double>> o7{std::in_place, 3.0, 4.0};

// копирование/присваивание:
auto oIntCopy = oInt;
```
##### Cпособы получения значения:
- value_or(default) — возвращает значение, если доступно, или же возвращает default.
- value() — возвращает значение или бросает исключение std::bad_optional_access.
- Использовать operator*() и operator->() так же, как в итераторах. Если объект не содержит реального значения, то поведение не определено!

```cpp
// с помощью operator*()
std::optional<int> oint = 10;
std::cout<< "oint " << *opt1 << '\n';

// с помощью value()
std::optional<std::string> ostr("hello");
try
{
    std::cout << "ostr " << ostr.value() << '\n';
}
catch (const std::bad_optional_access& e)
{
    std::cout << e.what() << "\n";
}

// с помощью value_or()
std::optional<double> odouble; // пустой
std::cout<< "odouble " << odouble.value_or(10.0) << '\n';
```

##### Некоторые функции
- swap (обменивает содержимое)
- reset (удалит содержимое или не сделает ничего(если пустой))
```cpp
int main()
{
std::optional <int> pr;

pr.emplace(2);
pr.reset(); // pr = std::nullopt
}
```
- emplace (создает содержимое на месте. если содержит значение перед вызовом, содержащееся
значение уничтожается путем вызова его деструктора)
```cpp
int main()
{
std::optional <int> pr;

pr.emplace(2);
}
```

- возможны обычные операции сравнение (небольшие проблемы, когда операнды std::nullopt)
```cpp
#include <optional>
#include <iostream>

int main()
{
    std::optional<int> oEmpty;
    std::optional<int> oTwo(2);
    std::optional<int> oTen(10);

    std::cout << std::boolalpha;
    std::cout << (oTen > oTwo) << "\n";
    std::cout << (oTen < oTwo) << "\n";
    std::cout << (oEmpty < oTwo) << "\n";
    std::cout << (oEmpty == std::nullopt) << "\n";
    std::cout << (oTen == 10) << "\n";
}
 //true  // (oTen > oTwo)
 //false // (oTen < oTwo)
 //true  // (oEmpty < oTwo)
 //true  // (oEmpty == std::nullopt)
 //true  // (oTen == 10)
```

##### Пример
```cpp
#include <optional>
#include <iostream>
#include <string>

std::optional<int> ParseInt(char*arg)
{
    try
    {
        return { std::stoi(std::string(arg)) };
    }
    catch (...)
    {
        std::cout << "cannot convert \'" << arg << "\' to int!\n";
    }

    return { };
}

int main(int argc, char* argv[])
{
    if (argc >= 3)
    {
        auto oFirst = ParseInt(argv[1]);
        auto oSecond = ParseInt(argv[2]);

        if (oFirst && oSecond)
        {
            std::cout << "sum of " << *oFirst << " and " << *oSecond;
            std::cout << " is " << *oFirst + *oSecond << "\n";
        }
    }
}
```

Класс _std::variant_ представляет собой union, который помнит, какой тип он хранит.
##### Некоторые функции
- get (получение значений из std::variant. Она выбросит исключение std::bad_variant_access, если попытаться взять не тот тип.)

```cpp
#include <iostream>
#include <variant>

int main()
{
  // хранит или int, или float или char.
  std::variant<int, float, char> v;
  v = 3.14f;
  v = 42;
  std::cout << std::get<int>(v);
  //std::cout << std::get<float>(v); // std::bad_variant_access
  //std::cout << std::get<char>(v); // std::bad_variant_access
  //std::cout << std::get<double>(v); // compile-error
  return 0;
}
```
- get_if (принимает указатель на std::variant и возвращает указатель на текущее значение, если тип был указан правильно, и nullptr в противном случае)
```cpp
#include <iostream>
#include <variant>

int main()
{
  std::variant<int, float, char> v;
  v = 42;
  auto ptr = std::get_if<int>(&v);
  if (ptr != nullptr)
  {
    std::cout << "int value: " << *ptr << '\n'; // int value: 42
  }

  return 0;
}
```
- visit (вызывает предоставленный функтор с агрументами, сожержащимися
в одной или нескольких вариантах)

```cpp
#include <iostream>
#include <variant>

int main()
{
  std::variant<int, float, char> v;
  v = 42;

  std::visit([](auto& arg)
  {
    using Type = std::decay_t<decltype(arg)>; //сам тип определяет
    if constexpr (std::is_same_v<Type, int>)
    {
      std::cout << "int value: " << arg << '\n';
    }
    else if constexpr (std::is_same_v<Type, float>)  //если одинаковый тип, то True
    {
      std::cout << "float value: " << arg << '\n';
    }
    else if constexpr (std::is_same_v<Type, char>)
    {
      std::cout << "char value: " << arg << '\n';
    }
  }, v);

  return 0;
}
```

Класс ```std::any``` – контейнер с безопасным типом для хранения одного значения любого типа. НЕ производит никаких приведений типов, что позволяет избежать неоднозначности.

_Cоздание_
```cpp
#include <any>

any var = object/value; //копировать инициализицаю
any var (object/value); // параметризированный конструктор

any var;
var = object/value; // использование оператора присваивания
```
##### Функции
- type (предоставляет информацию о хранящемся типе)
```cpp
#include <any>

int main()
{
  std::any a = 42;
  std::cout << a.type().name() << '\n'; // Напечатает "int"

  return 0;
}
```
- any_cast (доступ к информации, хранящейся в объекте any)
```cpp
#include <iostream>
#include <string>
#include <any>

int main()
{
  std::any a = 42;
  std::cout << std::any_cast<int>(a) << '\n';

  a = 11.34f;
  std::cout << std::any_cast<float>(a) << '\n';

  a = std::string{ "hello" };
  std::cout << std::any_cast<std::string>(a) << '\n';

  return 0;
}
```
- has_value (проверяет, содержит ли объект значение)
- reset (уничтожает содержащийся объект)
```cpp
#include <any>
#include <iostream>

int main()
{

    // any type
    std::any a = 1;

    if (a.has_value())
    {
        std::cout << a.type().name() << '\n';
    }

    // reset
    a.reset();
    if (!a.has_value())
    {
        std::cout << "no value\n";
    }
}
```
```std::string_view``` - это класс, не владеющий строкой, но хранящий указатель на начало строки и её размер. Таким образом мы не владеем строкой, а имеем "право просмотра". Функция будет работать как с аргументами const char*, так и string без выделения памяти со стороны программы.

##### Подключение
```cpp
#include <string_view>
```
Он может выполнять некоторые функции обычного string

- substr (возвращает подстроку)
```cpp
std::string str = "lllloooonnnngggg sssstttrrriiinnnggg"; //A really long string

//Bad way - 'string::substr' returns a new string (expensive if the string is long)
std::cout << str.substr(15, 10) << '\n';

//Good way - No copies are created!
std::string_view view = str;

// string_view::substr returns a new string_view
std::cout << view.substr(15, 10) << '\n';
```
- copy (копирует символы )
- find (поиск символов)
- swap (обмен сожержимым)

##### Другой пример
```cpp
#include <iostream>
#include <string>

int main()
{
  char text[]{ "hello" };
  std::string str{ text };
  std::string more{ str };

  std::cout << text << ' ' << str << ' ' << more << '\n'; // hello hello hello

  return 0;
}
```
#### 12. Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
---
_Лямбда-выражениями_ называются безымянные локальные функции, которые можно создавать прямо внутри какого-либо выражения.(лямбда-выражения в C++ — это краткая форма записи анонимных функторов.) По умолчанию лямба-функции возвращают void, однако при наличии одного return в лямбда-выражении, компилятор вычисляет тип возвращаемого значения самостоятельно. Если же в лямбда-выражении присутствует if или switch (или другие сложные конструкции) то надо указывать возвращаемый тип самостоятельно ```[] (int _n) -> double```
ЛЯбда-выражение всегда начинается с [], затем необязательный список параметров, а затем тело функции.
_Захват переменных из внешнего контекста_ - в лямбда-функции так же можно передавать переменные (список захвата), но при попытке изменить захваченные переменные получим ошибку (так как по умолчанию генерируемый operator()() объявлен как const), чтобы это обойти используем ключевое слово mutable. Так же можно передавать параметры по ссылке и использовать "режими захвата" ```[=] - по значению, [&] - по ссылке``` тогда все переменные используемые в лямбда-функции захватываются по умолчанию.
```cpp
[список захватываемых объектов](параметры) mutable exception -> ret {body}
//пример
auto Lambda = []() { std:: cout << "Hello";}
```
ret - возвращаемое значение лямбда функции
exception - лямбда функция также может выкидывать исключени

Список захватываемых параметров в отличие от аргументов функции не должны передаваться при вызове лямбда:
- [a, &b] где а захвачена по значению, а b по ссылке
- [this] захватывает указатель this
- [&] захватывает все символы по ссылке
- [=] захватывает все символы по значению
- [] ничего не захватывает

##### Пример лямбда-функции
```cpp
#include <iostream>
#include <vector>
#include <algorithm> //для for_each

int main()
{
    std::vector <int> a = {2,54,73,17,54,8,3,9,1,34,135,324}

    std::for_each(a.begin(), a.end(), [](int a) { if (a%2==0)
    {std::cout << a << " - четное число" << std::endl}})
}

```

_Функтор_ - это сокращенное от функциональный объект, представляющий собой конструкцию, позволяющую использовать
объект класса как функцию. В С++ для определения функтора достаточно описать класс, в котором переопределена
операция (). Также функторами являются любые объекты, которые умеют вести себя как функции: это указатели на функции, лямбда-функции и имена функций, но сами функции и ссылки на функции функторами не являются, потому что они в терминах С++ не объекты.

_Указатель на функцию_ -  по сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.
Виды:
- имя функции
- отдельная переменная
```cpp
тип (*имя_указателя)(параметры);
```

##### Пример
```cpp
#include <iostream>

void hello()
{
    std::cout << "Hello " << std::endl;
}

void bye()
{
    std::cout << "Bye " << std::endl;
}

int main()
{
    void(*message)();

    message = hello;
    message(); // можно так (*message)()

    message = bye;
    message();
}
```

_std::function<[function_type]>_ — полиморфная обёртка для функций, функторов, лямбда-выражений, функций-членов класса, привязки выражений (std::bind) и других вызываемых сущностей. Объект такого класса может копировать, хранить любой вызываемый объект: функцию, метод класса или лямбда-выражение. ГРубо говоря, в любом месте, где необходимо использовать указатель на функцию для ее
отложенного вызова или для создания функции обратного вызова может быть использован std::function.
Поведение схоже с поведением на функцию.

##### Подключение
```cpp
#include <functional>
```

_Некоторые функции_
- swap (меняет местами содержимое текущего объекта и переданного в параметре)
- operator bool (проверяет, что экземпляр хранит не пустое значение)
- target (получает указатель на хранимую в std::function функцию)
##### Пример
```cpp
#include <functional>
#include <iostream>

void sampleFunction()
{
    std::cout << "This is the sample function!\n";
}

void checkFunc( std::function<void()> &func )
{
    // Use operator bool to determine if callable target is available.
    if( func )
    {
        std::cout << "Function is not empty! Calling function.\n";
        func();
    }
    else
    {
        std::cout << "Function is empty. Nothing to do.\n";
    }
}

int main()
{
    std::function<void()> f1;
    std::function<void()> f2( sampleFunction );

    std::cout << "f1: ";
    checkFunc( f1 );

    std::cout << "f2: ";
    checkFunc( f2 );
}
```

##### Пример общий
```cpp
#include <functional>
#include <iostream>
#include <vector>

void smaller (int d)
{
    if (d < 17)
    {
    std::cout << d << "  ";
    }
}

void divided (int d)
{
    if (d % 3 == 0)
    {
    std::cout << d << "  ";
    }
}

void work (std::vector <int> v,  std::function <void(int)> f)
{
    for (auto x : v)
    {
    f(x);
    }
}

int main()
{
    std::vector <int> te = {45,77,99,2,3,56,12,556,43,765,23};

    work(te, divided);
    std::cout << std::endl;
    work(te, smaller);
}
```

#### 13. R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
---
В С++ все переменные являются l-values(значение, которое имеет свой адрес памяти). Находятся в левой стороне от операции присваивания. r-values - это значение, которое не имеет постоянного адреса в памяти.
##### Пример
```cpp
int a;
а  = 5 ;
а = а + 2; //слева а - l-values, а справа r-values
```
Rvalue ссылки - ссылки, которые инициализируются только значениями r-values (создается с ипользованием &&). Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. Основное отличие rvalue от lvalue в том, что объекты rvalue могут быть перемещены, тогда как объекты lvalue всегда копируются.
##### Плюсы:
- они увеличивают продолжительность жизни объекта, которым инициализируются, до продолжительности жизни ссылки r-values (ссылки l-values на константные объекты также могут это сделать)
- неконстантные ссылки r-values позволяют нам изменять значения r-values, на которые указывают ссылки r-values.
```cpp
int x = 7;
int &l = x; //l-values ссылка
int &&r = x; //r-values ссылка
```
Чаще всего r-values ссылки используют как параметры функции. Это наиболее полезно при перегрузке функций,
когда вы хотите, чтобы выполение функции отличалось в зависимости от аргументов.
Вы не должны возвращать ссылку r-values из функции, как и l-values. В большинстве случаев вы будете вовзращать висячую ссылку
(указывающую на удаленную память), а объект, на который будет ссылаться ссылка - выйдет
из области видимости в конце функции.
##### Пример
```cpp
#include <iostream>

void fun (const int &l)
{
    std::cout << "l-values reference";
}

void fun (int &&l)
{
    std::cout << "r-values reference";
}
int main()
{
    int x = 7;

    fun(x); //аргумент l-values
    fun(4); //аргумент r-values
}
```
_Cемантика перемещения_ означает, что класс, вместо копирования, передает право собственности на объект.

```std::move()``` — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. Мы можем передать l-value в std::move(), и std::move() вернёт нам ссылку r-value.
##### Пример
```cpp
#include <iostream>
#include <string>
#include <utility>
#include <vector>

int main()
{
	std::vector<std::string> v;
	std::string str = "Bye";

	std::cout << "Copying str\n";
	v.push_back(str); // вызывает версию l-value метода push_back, которая копирует str в элемент массива

	std::cout << "str: " << str << '\n'; //Bye
	std::cout << "vector: " << v[0] << '\n'; // Bye

	std::cout << "\nMoving str\n";

	v.push_back(std::move(str)); // вызывает версию r-value метода push_back, которая перемещает str в элемент массива

	std::cout << "str: " << str << '\n'; // ничего
	std::cout << "vector: " << v[0] << ' ' << v[1] << '\n';  //Bye Bye

	return 0;
}
```

```std::forward``` представляет собой условное приведение (в отличии от ```std::move```), эта функция выполняет приведение к rvalue только тогда, когда ее аргумент инициализирован rvalue, иначе
возвращает lvalue без изменения ее типа.

###### Пример
```cpp
#include <utility>      // std::forward
#include <iostream>     // std::cout

// function with lvalue and rvalue reference overloads:
void overloaded (const int& x) {std::cout << "[lvalue]\n";}
void overloaded (int&& x) {std::cout << "[rvalue]\n";}

// function template taking rvalue reference to deduced type:
template <class T> void fn (T&& x) {
  overloaded (x);                   // always an lvalue
  overloaded (std::forward<T>(x));  // rvalue if argument is rvalue
}

int main () {
  int a;
  std::cout << "calling fn with lvalue: ";
  fn (a);

  std::cout << "calling fn with rvalue: ";
  fn (0);

  return 0;
}
```

#### 14. Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
---
_throw_ генерирует исключение, затем в блок после ключевого слова _try_ помещается код, который потенциально может сгенерировать исключение, после ключевого слова _catch_ в скобках идет параметр, который передает информацию об исключении. Затем в блоке производится собственно обработка исключения.

Важно:
- при выбрасывании исключения (throw), точка выполнения программы немедленно переходит к ближайшему блоку try. Затем в блок catch, который прикреплен к этому try и обрабатывает этот тип исключения.
- если нет подходящего блока catch, то переходит к следующему try, если же вообще не будет найдено подходящее, то программа закончится с ошибкой исключения.
- компилятор не выполняет неявные преобразования при сопоставлении исключений с блоками catch. Исключение типа char не будет обрабатываться блоком catch типа int и так далее.

##### Пример
```cpp
#include <iostream>

int main()
{
    try{

    throw 4.2; //исключение типа double
    std::cout << "This never prints";
    }

    catch(double a)
    {
        std::cerr << a;
    }
}
```

- _Resource Acquisition Is Initialization_ - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением. (Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.)
```cpp
class Massiv
{

private:
    int *m_array;

public:
    Massiv(int length)
    {
    assert (length > 0)

    m_array = new int[length];
    }

    ~Massiv()
    {
    delete[] m_array;
    }
};
```
_Внимание!_ если вы используете функцию exit(), то ваша программа завершится, и никакие деструкторы
не будут вызваны.

_noexcept_ - спецификатор времени компиляции, которой говорит компилятору о том, что функция не будет выбрасывать исключения.
##### Плюсы
- оптимизаторам не надо поддерживать стек в сворачиваемом состоянии
- оптимизаторам не нужно гарантировать, что объекты в такой функции будут уничтожены в порядке, обратном созданию, если вдруг такую функцию покинет исключени.
##### Пример
```cpp
void f() noexcept;  //наиболее оптимизируемая
void f() throw();  //менее оптимизируемая
void f() ;  //менее оптимизируемая
```
#### 15. RAII. «Умные» указатели. std::shared_ptr. Примеры.
---
_Smart pointer_ — это объект, работать с которым можно как с обычным указателем, но при этом, в отличии от последнего, он предоставляет некоторый дополнительный функционал (например, автоматическое освобождение закрепленной за указателем области памяти).

Умные указатели призваны для борьбы с утечками памяти, которые сложно избежать в больших проектах. Они особенно удобны в местах, где возникают исключения, так как при последних происходит процесс раскрутки стека и уничтожаются локальные объекты. В случае обычного указателя — уничтожится переменная-указатель, при этом ресурс останется не освобожденным. В случае умного указателя — вызовется деструктор, который и освободит выделенный ресурс.
Одним из умных указателей является _shared_ptr_ (указатель на объект, которым владеет
сразу несколько объектов). Он реализует подсчет ссылок на ресурс. Ресурс освободится тогда,
когда счетчик ссылок на него будет равным 0. То есть система реализует одно из основных
правил сборщика мусора. Указатель можно как перемещать, так и копировать. Число существующих указателей отслеживается при помощи счетчика ссылок.
shared_ptr использует внутри два указателя. Один указывает на передаваемый ресурс, а второй указывает на «блок управления» — динамически выделенный объект, который отслеживает кучу разных вещей, включая и то, сколько std::shared_ptr одновременно указывают на каждый полученный ресурс. При создании std::shared_ptr с помощью конструктора std::shared_ptr, память для полученного ресурса и блока управления (которого также создаёт конструктор) выделяется отдельно. Однако в std::make_shared() это оптимизировано в единое выделение памяти, что, соответственно, повышает производительность.

При помощи этого указателя можно создавать циклические ссылки: есть два объекта. ПЕрвый ссылается
при помощи shared_ptr на второй, а второй на первый. Счетчики никогда не обнулятся, и объекты никогда
не будут уничтожены.
##### Создание
```cpp
#include <memory>

std::shared_ptr<int> x_ptr (new int (45)); // 1 вариант
auto ptr = std::make_shared<int>();  //проще, безопаснее и производительнее
```

##### Пример
```cpp

#include <iostream>
#include <memory> // для std::shared_ptr

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

int main()
{
	// Выделяем Item и передаём его в std::shared_ptr
	Item *item = new Item;
	std::shared_ptr<Item> ptr1(item);
	//auto ptr1 = std::make_shared<Item>();
	{
		std::shared_ptr<Item> ptr2(ptr1); // используем оператор присваивания копированием для создания второго std::shared_ptr из ptr1, указывающего на тот же Item
        //нельзя использовать std::shared_ptr<Item> ptr2(item);
        //auto ptr2 = ptr1; используем семантику копирования
		std::cout << "Killing one shared pointer\n";
	} // ptr2 выходит из области видимости здесь, но больше ничего не происходит

	std::cout << "Killing another shared pointer\n";

	return 0;
} // ptr1 выходит из области видимости здесь и выделенный Item уничтожается также здесь
```
Разница здесь в том, что мы создали два отдельных, независимых друг от друга, умных указателя std::shared_ptr. Как следствие, хотя они оба указывают на один и тот же Item, они не знают о существовании друг друга. Когда ptr2 выходит из области видимости, он думает, что является единственным владельцем Item-а, поэтому уничтожает его. Когда позже ptr1 выходит из области видимости, он думает так же и пытается снова удалить (уже удалённый) Item.

##### Некоторые функции

- get (возвращает указатель на управляемый объект)

```cpp
#include <iostream>
#include <memory>

int main () {
  int* p = new int (10);
  std::shared_ptr<int> a (p);

  if (a.get()==p)
    std::cout << "a and p point to the same location\n";

  // three ways of accessing the same address:
  std::cout << *a.get() << "\n";
  std::cout << *a << "\n";
  std::cout << *p << "\n";

  return 0;
}
```

- use_count (возвращает количество объектов shared_ptr, которые ссылаются на тот же управляемый
объект)

```cpp
#include <memory>
#include <iostream>

void fun(std::shared_ptr<int> sp)
{
    std::cout << "fun: sp.use_count() == " << sp.use_count() << std::endl; // 2
}

int main()
{
    std::shared_ptr<int> sp1 {std::make_shared<int>(5)};
    std::cout << "sp1.use_count() == " << sp1.use_count() << std::endl; // 1

    fun(sp1);
}
```

- swap (обмен содержимым)

```cpp
// shared_ptr::swap example
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> foo (new int(10));
  std::shared_ptr<int> bar (new int(20));

  foo.swap(bar);

  std::cout << "*foo: " << *foo << '\n'; //20
  std::cout << "*bar: " << *bar << '\n'; //10

  return 0;
}
```
- reset (заменяет объект, которым владеет)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp;  // empty

  sp.reset (new int);       // takes ownership of pointer
  *sp=10;
  std::cout << *sp << '\n';

  sp.reset (new int);       // deletes managed object, acquires new pointer
  *sp=20;
  std::cout << *sp << '\n';

  sp.reset();               // deletes managed object

  return 0;
}
```

_Shared и многопоточность_
Подсчет ссылок в shared_ptr построен с использованием атомарного счетчика (операция
называется атомарной, если она завершается в один шаг относительно других потоков, имеющихдоступ к этой памяти)
. ЕСли какой-то shared_ptr доступен разным потокам и может быть модифицирован, то
необходимо позаботиться о синхронизации доступа к этому экземпляру
shared_ptr.

#### 16. RAII. «Умные» указатели. std::unique_ptr. Примеры.
---
- Шаблонный класс unique_ptr представляет собой уникальный указатель на объект.Его нужно использовать для управления
 любым динамически выделенным объектом/ресурсом, но с условием, что unique_ptr полность владеет переданным
 ему объектом, а не делится владением еще с другими классами. Указатель нельзя копировать, но можно передавать владение им с помощью std::move. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает.


##### Cоздание
```cpp
#include <memory>

std::unique_ptr<int> item(new int); // 1
auto f2 = std::make_unique<int>(new int); //std::make_unique() решает проблему безопасности использования исключений, которая может возникнуть в результате неопределённого порядка обработки аргументов функции
```
```cpp
some_function(std::unique_ptr<T>(new T), function_that_can_throw_exception());
```
Здесь компилятору предоставляется большая гибкость при обработке вызова функции. Он может сначала выделить новый T, затем вызвать function_that_can_throw_exception(), а затем уже создать std::unique_ptr, который управляет динамически выделенным T. Если function_that_can_throw_exception() выбросит исключение, то выделенный T не будет корректно удалён, поскольку умный указатель, который должен выполнить его удаление — не успеет создаться. Это приведёт к утечке памяти.

```cpp
#include <iostream>
#include <memory> // для std::unique_ptr

class Item
{
public:
	Item() { std::cout << "Item acquired\n"; }
	~Item() { std::cout << "Item destroyed\n"; }
};

int main()
{
	std::unique_ptr<Item> item1(new Item); // выделение Item
	std::unique_ptr<Item> item2; // присваивается значение nullptr

	// item2 = item1; // не скомпилируется: семантика копирования отключена
	item2 = std::move(item1); // item2 теперь владеет item1, а для item1 присваивается значение null

	return 0;
} // Item уничтожается здесь, когда item2 выходит из области видимости
```
Поскольку std::unique_ptr разработан с учётом семантики перемещения, то семантика копирования по умолчанию отключена. Если вы хотите передать содержимое, управляемое std::unique_ptr, то вы должны использовать семантику перемещения. В программе выше мы передаём содержимое std::unique_ptr с помощью std::move() (который конвертирует item1 в r-value, которое является триггером для выполнения семантики перемещения вместо семантики копирования).

std::unique_ptr имеет перегруженные операторы * и ->, которые используются для доступа к хранимым объектам. Оператор * возвращает ссылку на управляемый ресурс, а оператор -> возвращает указатель.
```cpp
#include <iostream>
#include <memory>

struct Foo {
    void bar() { std::cout << "Foo::bar\n"; }
};

void f(const Foo& foo)
{
    std::cout << "f(const Foo&)\n";
}

int main()
{
    std::unique_ptr<Foo> ptr(new Foo);

    ptr->bar();
    f(*ptr);
}  // Foo::bar   f(const Foo&)
```
##### Некоторые функции

- get (возвращает указатель на управляемый объект)
```cpp
#include <iostream>
#include <memory>

int main () {
                                           // foo   bar    p
                                           // ---   ---   ---
  std::unique_ptr<int> foo;                // null
  std::unique_ptr<int> bar;                // null  null
  int* p = nullptr;                        // null  null  null

  foo = std::unique_ptr<int>(new int(10)); // (10)  null  null
  bar = std::move(foo);                    // null  (10)  null
  p = bar.get();                           // null  (10)  (10)

  delete p;   // the program is now responsible of deleting the object pointed to by p
              // bar deletes its managed object automatically

  return 0;
}
```

- reset (заменяет управляемый объект)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> up;  // empty

  up.reset (new int);       // takes ownership of pointer
  *up=5;
  std::cout << *up << '\n'; // 5

  up.reset (new int);       // deletes managed object, acquires new pointer
  *up=10;
  std::cout << *up << '\n'; // 10

  up.reset();               // deletes managed object

  return 0;
}
```

- release (возвращает указатель на управляемый объект и освобождает собственнось)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> auto_pointer (new int);
  int * manual_pointer;

  *auto_pointer=10;

  manual_pointer = auto_pointer.release();
  // (auto_pointer is now empty)

  std::cout << "manual_pointer points to " << *manual_pointer << '\n';

  delete manual_pointer;

```

- swap (обменивает управляемые объекты)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::unique_ptr<int> foo (new int(10));
  std::unique_ptr<int> bar (new int(20));

  foo.swap(bar);

  std::cout << "foo: " << *foo << '\n'; //20
  std::cout << "bar: " << *bar << '\n'; //10

  return 0;
}
```

##### Ошибки
- Во-первых, не позволяйте нескольким классам «владеть» одним и тем же ресурсом.

```cpp
Item *item = new Item;
std::unique_ptr<Item> item1(item);
std::unique_ptr<Item> item2(item);
```
Хотя это синтаксически допустимо, конечным результатом будет то, что и item1, и item2 попытаются удалить Item, что приведёт к неопределённому поведению/результатам.
- Во-вторых, не удаляйте выделенный ресурс вручную из-под std::unique_ptr
```cpp
Item *item = new Item;
std::unique_ptr<Item> item1(item);
delete item;
```
Если вы это сделаете, std::unique_ptr попытается удалить уже удалённый ресурс, что снова приведёт к неопределённому поведению/результатам.
Также возможно _передавать_ (использовать std::move()) и _возвращать_ (не должны возвращать std::unique_ptr по адресу (вообще) или по ссылке (если у вас нет на это веских причин) unique_ptr из функции

#### 17. RAII. «Умные» указатели. std::weak_ptr. Примеры.
---

Одной из проблем при работе является с ```std::shared_ptr``` является возможность создания циклической ссылки (например когда два объекта ссылаются друг на друга, таким образом счетчик не обнулится и не будет вызван деструктор утечки памяти).

Эту проблему можно решить при помощи использования ```std::weak_ptr``` — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.
##### Пример
```cpp
#include <iostream>
#include <memory> // для std::shared_ptr и std::weak_ptr
#include <string>

class Human
{
	std::string m_name;
	std::weak_ptr<Human> m_partner; // обратите внимание, здесь std::weak_ptr

public:

	Human(const std::string &name): m_name(name)
	{
		std::cout << m_name << " created\n";
	}
	~Human()
	{
		std::cout << m_name << " destroyed\n";
	}

	friend bool partnerUp(std::shared_ptr<Human> &h1, std::shared_ptr<Human> &h2)
	{
		if (!h1 || !h2)
			return false;

		h1->m_partner = h2;
		h2->m_partner = h1;

		std::cout << h1->m_name << " is now partnered with " << h2->m_name << "\n";

		return true;
	}
};

int main()
{
	auto anton = std::make_shared<Human>("Anton");
	auto ivan = std::make_shared<Human>("Ivan");

	partnerUp(anton, ivan);

	return 0;
}
```
Когда ivan выходит из области видимости, он видит, что нет другого std::shared_ptr, указывающего на Ivan-а (std::weak_ptr из Anton-а не считается). Поэтому он уничтожает Ivan-а. То же самое происходит и с Anton-ом.

##### Функции

- lock (создает shared_ptr, который управляет объектом, на который ссылается weak_ptr)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp1,sp2;
  std::weak_ptr<int> wp;
                                       // sharing group:
                                       // --------------
  sp1 = std::make_shared<int> (20);    // sp1
  wp = sp1;                            // sp1, wp

  sp2 = wp.lock();                     // sp1, wp, sp2
  sp1.reset();                         //      wp, sp2

  sp1 = wp.lock();                     // sp1, wp, sp2

  std::cout << "*sp1: " << *sp1 << '\n'; //20
  std::cout << "*sp2: " << *sp2 << '\n'; //20

  return 0;
}
```

- expired (проверяет, был ли удален объект, на который ссылается weak_ptr (true, если управляемый объект уже удалён, false — если остался в памяти.))
```cpp
#include <iostream>
#include <memory>

std::weak_ptr<int> gw;

void f()
{
    if (!gw.expired()) {
    std::cout << "gw is valid\n";
    }
    else {
        std::cout << "gw is expired\n";
    }
}

int main()
{
    {
        auto sp = std::make_shared<int>(42);
    gw = sp;

    f();
    }

    f();
}
```
- reset (прекращает владение управляемым объектом)
```cpp
#include <iostream>
#include <memory>

int main () {
  std::shared_ptr<int> sp (new int(10));

  std::weak_ptr<int> wp(sp);

  wp.reset();

  std::cout << "2. wp ";
   if (wp.expired()==false)
   std::cout << "is" << " expired\n";

  return 0;
}
```
#### 18. Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
---

Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаимодействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол  без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол, устанавливающий соединение.

Для работы с сетью традиционно используются сокеты.
Сокет – это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами. Мы можем писать и читать данные из сокета почти так же, как из обычного файла.

Функция _socket_ - создает новый сокет с заданными параметрами.
```cpp
//s = socket(int domain, int type, int protocol);
//domain - целое число, домен связи
// type - тип связи
// protocol значение протокола для интернет-протокола(IP), равное 0.

int sock_udp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
int sock_tcp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

Функция _bind_ - связывает сокет с конкретным адресом и номером порта.
Когда сокет создается при помощи socket(), он ассоциируется с некоторым семейством адресов,
но не с некоторым адресом. ДО того как сокет сможет принять входящие данные соединения, он
должен быть связан с адресом.
ПРинимает три аргумента:
- sockfd - дескриптор, представляющий сокет при привязке
- serv_addr - указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
- addrlen - поле socklen_t, представляющее длину структуры sockaddr
Функция возвращает 0 _при успехе_ и -1 _при ошибке_
```cpp
int bind(int sockfd,
         const struct sockaddr *serv_addr,
         socklen_t addrlen);
```
Где `sockaddr` - семейство структур, описывающих адреса (`sockaddr_in` - для сетевого взаимодействияб `sockaddr_un` для межпроцессорного):
Структура `sockaddr_in`:
```cpp
struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
```

Функция _listen_ - подготавливает привязываемый сокет к принятию входящих
соединений.Данная функция применима только в типам сокетов SOCK_STREAM и SOCK_SEQPACKET.
Принимает два аргумента:
- sockfd - корректный дескриптор сокета
- backlog - целое число, означающее число установленных соединений, которые могут быть обработаны в любой момент времени. Операционная система обычно ставит его равным максимальному значению.
После принятия соединения оно выводится из очереди. В случае успеха возвращается 0,
в случае ошибки -1.

```cpp
int listen(int sockfd, int backlog);
```
Функция _listen_ принимает дескриптор слушающего сокета и размер очереди запросов. Когда клиент пытается соединиться с сервером, его запрос ставится в очередь, так как сервер может быть занят обработкой других запросов. Если очередь заполнена, все последующие запросы будут игнорироваться.

Функция _accept_ ожидает клиентские соединения. Является блокирующей
Аргументы:
- sockfd - дескриптор слушающего сокета на принятие соединения
- cliaddr - указатель на структуру sockaddr, для принятия информации об адресе клиента.
- addrlen - указатель на socklen_t, определяющее размер структуры, содержащей клиентский адрес и переданной в accept(). Когда accept()возвращает значение, socklen_t указывает сколько байт структуры cliaddr использовано в данный момент
Функция возвращает дескриптор сокета, связанный с принятым соединением, или -1 в случае ошибки.
```cpp
int accept(int sockfd,
           struct sockaddr *addr,
           socklen_t *addrlen);

```

Функция _connect_ соединяет пользовательский сокет с удаленным сокетом.
Возвращает целое число, представляющее код ошибки:
- 0 - успешно всё
- 1 - есть ошибка
Эта функция используется на клиенской стороне подключения, так как именно
клиент является инициатором подключения.
Загруженный сервер может отвергнуть попытку соединения, поэтому в некоторых видах
программ необходимо предусмотреть повторные попытки соединения.

```cpp
int connect(int sockfd,
            const struct sockaddr *addr,
            socklen_t addrlen);
```

#### 19. Сетевое взаимодействие. Сокеты. Библиотека boost asio.
---
Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаимодействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол  без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол, устанавливающий соединение.

Для работы с сетью традиционно используются сокеты.
Сокет – это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами. Мы можем писать и читать данные из сокета почти так же, как из обычного файла.

Boost.Asio - кросс-платформенная С++ библиотека для программирования сетевых приложений и других низкоуровневых программ ввода/вывода.
Boost.Asio успешно абстрагирует понятия input и output, которые работают не только для работы в сети, но и для последовательных COM-портов, файлов и так далее. Кроме этого вы можете делать input или output программирование синхронным или асинхронным:
```cpp
read(stream, buffer [, extra options])
async_read(stream, buffer [, extra options], handler)
write(stream, buffer [, extra options])
async_write(stream, buffer [, extra options], handler)
```
Как вы успели заметить в предыдущем фрагменте кода функции принимают экземпляр потока, которым может быть что угодно (не только сокет, мы можем читать и писать в него).
Библиотека является переносимой, работает на большинстве операционных систем и хорошо масштабируется при более чем тысяче одновременных подключений.
Boost.Asio это чисто заголовочная библиотека. Однако, в зависимости от компилятора и размера вашей программы, вы можете выбрать создание Boost.Asio как исходного файла. Вы можете сделать это для уменьшения времени компиляции. Это может быть сделано следующими способами:
- Только в одном из ваших файлов, используя #include <boost/asio/impl/src.hpp> (если вы используете SSL, то #include <boost/asio/ssl/impl/src.hpp>)
- Используя #define BOOST_ASIO_SEPARATE_COMPILATION во всех ваших исходных файлах

Используйте BOOST_ASIO_DISABLE_THREADS, если установлено; он отключает поддержку потоков в Boost.Asio, независимо от того был ли Boost скомпилирован с поддержкой потоков.

_Boost.Asio использует io_service_ для общения с сервисом ввода/вывода операционной системы. Обычно одного экземпляра io_service бывает достаточно. Далее создайте адрес и порт к которому вы хотите подключиться. Создайте сокет. Подключите сокет к вашему адресу и порту. Опять же, ваша первая программа должна иметь, по крайней мере, хотя бы один экземпляр io_service. Затем вы указываете порт для прослушивания и создаете акцептор (приемник) — один объект, который принимает клиентские подключения.
                                                                                                                                                                                                                                                                             В следующем цикле вы создаете фиктивный сокет и ждете подключение клиента. После того как соединение установлено, вы создаете поток, который будет заниматься этой связью.
                                                                                                                                                                                                                                                                             В потоке, в функции client_session вы слушаете запросы клиента, интерпретируете их и отвечаете.
##### Простой синхронный клиент
```cpp
//Here is a simple synchronous server:using boost::asio;
typedef boost::shared_ptr<ip::tcp::socket> socket_ptr;
io_service service;
ip::tcp::endpoint ep( ip::tcp::v4(), 2001)); // listen on 2001
ip::tcp::acceptor acc(service, ep);
while ( true)
{
    socket_ptr sock(new ip::tcp::socket(service));
    acc.accept(*sock);
    boost::thread( boost::bind(client_session, sock));
}
void client_session(socket_ptr sock)
 {
    while ( true)
     {
        char data[512];
        size_t len = sock->read_some(buffer(data));
        if ( len > 0)
        write(*sock, buffer("ok", 2));
    }
}
```

##### Пример синхронного клиента
```cpp
using boost::asio;
io_service service;
ip::tcp::endpoint ep( ip::address::from_string("127.0.0.1"), 2001);
ip::tcp::socket sock(service);
sock.async_connect(ep, connect_handler);
service.run();
void connect_handler(const boost::system::error_code & ec)
 {
    // here we know we connected successfully
    // if ec indicates success
}
```
Ваша программа должна иметь, по крайней мере один экземпляр io_service. Вы указываете где подключается и создается сокет. Затем, как только установлено соединение, вы асинхронно подключаетесь к адресу и порту (это завершение обработчика), то есть вызывается connect_handler.
После вызова connect_handler проверьте код на ошибки(ec), и в случае успеха вы можете асинхронно написать серверу.
Обратите внимание, что цикл service.run() будет выполняться до тех пор пока имеются незаконченные асинхронные операции. В предыдущем примере есть только одна такая операция, это сокет async_connect. После этого service.run() завершается.
Каждая асинхронная операция имеет завершающий обработчик, функцию, которая будет вызвана, когда операция завершится.

_Исключения против кодов ошибок_

Boost.Asio позволяет использовать как исключения так и коды ошибок. Все синхронные функции имеют перегрузки выбрасывающие исключения в результате ошибки или возвращает код ошибки. Если функция падает, то она выбрасывает boost::system::system_error ошибку.

```cpp
using boost::asio;
ip::tcp::endpoint ep;
ip::tcp::socket sock(service);
sock.connect(ep);
boost::system::error_code err;
sock.connect(ep, err); //В предыдущем коде sock.connect(ep) выбрасывает исключение в случае ошибки и sock.connect(ep, err) вернет код ошибки.
```
_Или_
```cpp
try
 {
    sock.connect(ep);
}
catch(boost::system::system_error e)
{
    std::cout << e.code() << std::endl;
}
```

Когда дело доходит до _потоков в Boost.Asio_, нам надо поговорить о следующем:
- io_service: класс io_service является потоко-безопасным. Несколько потоков могут вызвать io_service::run(). Чаще всего вы, вероятно, вызываете io_service::run() из одного потока, так что функция ждет пока все блокирующие асинхронные функции будут выполнены. Тем не менее вы можете вызывать io_service::run() из нескольких потоков. Это блокирует все потоки, которые будут вызывать io_service::run(). Все функции обратного вызов будут вызваны в контекстах вех потоков, которые вызвали io_service::run(); это так же означает, что если вы вызвали io_service::run(), только в одном потоке, то все функции обратного вызова будут вызваны в контексте данного потока.
- socket: классы сокетов не являются потоко-безопасными. Таким образом вам следует избегать таких ситуаций как читать из сокета в одном потоке, а писать в него в другом (это рекомендуется вообще, не говоря уже о Boost.Asio).
- utility: Классы utility обычно не имеет смысла использовать в нескольких потоках, они не потоко-безопасны. Большинство из них используются короткое время, а затем выходят из области видимости.

Boost.Asio в дополнение к сетям предоставляет и другие объекты ввода/вывода.
Boost.Asio позволяет использовать такие сигналы как SIGTERM (завершить программу), SIGINT(прерывание сигнала), SIGSEGV (нарушение сегмента) и другие.
Вы создаете экземпляр signal_set и указываете какие сигналы ждать асинхронно и когда один из них случится, то вызовется ваш асинхронный обработчик:
```cpp
void signal_handler(const boost::system::error_code & err, int signal)
{
    // log this, and terminate application
}
boost::asio::signal_set sig(service, SIGINT, SIGTERM);
sig.async_wait(signal_handler);
```
Если сгенерируется SIGINT, то вы попадете в обработчик signal_handler.

После открытия вы можете установить некоторые параметры, такие как скорость передачи данных порта, четность, стоп-биты, как указано в следующем фрагменте кода:
```cpp
serial_port::baud_rate rate(9600);
sp.set_option(rate);
```
Если порт открыт, то вы можете обрабатывать его в потоке, к тому же рекомендуется использовать свободные функции для чтения и/или записи в последовательный порт, например, read(), async_read(), write(), async_write(), как показано в следующем примере:
```cpp
char data[512];
read(sp, buffer(data, 512));
```




_Класс io_service_

Вы уже видели, что большая часть кода, которая использует Boost.Asio будет использовать некоторый экземпляр io_service. io_service – самый важный класс в библиотеке, он имеет дело с операционной системой, ждет конца всех асинхронных операций, а потом при завершении вызывает обработчик для каждой такой операции.
Если вы решили создать ваше приложение синхронным, то вам не нужно беспокоиться о том, что я собираюсь показать в этом разделе.
Вы можете использовать экземпляр io_service несколькими способами. В следующих

-Один поток с одним экземпляром io_service и одним обработчиком:
```cpp
io_service service_;
// all the socket operations are handled by service_
ip::tcp::socket sock1(service_);
// all the socket operations are handled by service_
ip::tcp::socket sock2(service_);
sock1.async_connect( ep, connect_handler);
sock2.async_connect( ep, connect_handler);
deadline_timer t(service_, boost::posix_time::seconds(5));
t.async_wait(timeout_handler);
service_.run();
```

- Много потоков с одним экземпляром io_service и несколькими обработчиками:
```cpp
io_service service_;
ip::tcp::socket sock1(service_);
ip::tcp::socket sock2(service_);
sock1.async_connect( ep, connect_handler);
sock2.async_connect( ep, connect_handler);
deadline_timer t(service_, boost::posix_time::seconds(5));
t.async_wait(timeout_handler);
for ( int i = 0; i < 5; ++i)
    boost::thread( run_service);
void run_service()
{
    service_.run();
}
```
- Много потоков с несколькими экземплярами io_service и несколькими обработчиками:
```cpp
io_service service_[2];
ip::tcp::socket sock1(service_[0]);
ip::tcp::socket sock2(service_[1]);
sock1.async_connect( ep, connect_handler);
sock2.async_connect( ep, connect_handler);
deadline_timer t(service_[0], boost::posix_time::seconds(5));
t.async_wait(timeout_handler);
for ( int i = 0; i < 2; ++i)
    boost::thread( boost::bind(run_service, i));

void run_service(int idx)
{
    service_[idx].run();
}
```
Прежде всего обратите внимание на то, что вы не можете иметь несколько экземпляров io_service в одном потоке. Не имеет смысла писать следующий код:
```cpp
for ( int i = 0; i < 2; ++i)
    service_[i].run();
```
Предыдущий участок кода не имеет никакого смысла, потому что service_[1].run() потребует service_[0].run() при закрытии первого. Так что все асинхронные операции service_[1] должны будут ждать обработки, а это не очень хорошая идея.

Вот что вы должны извлечь из предыдущих примеров:
- Ситуация 1 для базовых приложений. Вы всегда будете сталкиваться с проблемами, если несколько обработчиков должны быть вызваны одновременно или же если они должны будут вызываться последовательно. Если один обработчик требует много времени для окончания, то остальным обработчикам придется подождать.
- Ситуация 2 для большинства случаев. Это очень хорошо, если несколько обработчиков должны быть вызваны одновременно и каждый из них вызывается в отдельном потоке. Единственное узкое место может возникнуть, если все обрабатывающие потоки заняты и в то же время должны быть вызваны новые обработчики. Тем не менее, в качестве простого решения можно просто увеличить количество потоков-обработчиков.
- Ситуация 3 является наиболее сложной и более гибкой. Вы должны ее использовать только тогда, когда ситуации 2 недостаточно. Это вероятно будет возможно, когда у вас имеется более тысячи одновременных подключений (сокетов). Вы можете считать, что каждый поток-обработчик (поток, запустивший io_service::run()) имеет свой собственный цикл select/epoll; он ждет все сокеты, контролирует операции чтения/записи и найдя хотя бы одну такую операцию начинает обрабатывать ее. В большинстве случаев вам не о чем беспокоиться, беспокоиться можно только в том случае, когда количество сокетов растет экспоненциально (более 1000 сокетов). В таком случае наличие нескольких циклов select/epoll может увеличить время отклика.

И наконец всегда помните, что .run() всегда будет закончен, если больше нет операций для контроля.

_Boost.Asio является сложной библиотекой, которая делает программирование сетей довольно простым. Собрать ее просто. Она работает достаточно хорошо, избегая использования макросов; предоставляется несколько макросов для включения опций вкл/выкл, но есть несколько вещей, о которых нельзя забывать.
Boost.Asio поддерживает как синхронное так и асинхронное программирование. Эти два подхода очень разные и вы должны выбрать какой-то один и как можно раньше, так как переключение является довольно сложным и подвержено ошибкам.
Если вы выбрали синхронный подход, то вы можете выбирать между исключениями и кодами ошибок, переход от исключений к кодам ошибок довольно прост, надо добавить еще один аргумент в вызов функции (код ошибки).
Boost.Asio служит не только для программирования сетей. У этой библиотеки есть несколько особенностей, которые делают ее более ценной, такие как сигналы, таймеры и так далее.
В следующей главе мы будем вникать в множество функций и классов Boost.Asio, предусматривающие сети. Кроме того мы узнаем несколько трюков об асинхронном программировании._

Example:
```cpp
// Initialization
boost::system::error_code error;

boost::asio::io_service ioService{};
boost::asio::ip::tcp::socket socket{ioService, error};

...
...

// Binding to port
boost::asio::ip::tcp::endpoint endPoint{boost::asio::ip::v_4(), port};

socket.bind(endPoint, error);

...
...

// Connecting to server
socket.connect(someEndPoint, error);

...
...

// Read-write
std::string request;
request.resize(SOCKET_INPUT_BUFFER_SIZE);

socket.read_some(boost::asio::buffer(request), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while reading from socket : " << error;
  return error;
}

std::string response = HandleRequest(request, error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while handling request : " << error;
  return error;
}

socket.write_some(boost::asio::buffer(response), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while writing to socket : " << error;
  return error;
}
```

#### 20. Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
---
_Контекст потоков_

Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду. В системе количество потоков может превышать (а на самом деле, почти всегда превышает) число ядер. И чтобы задачи могли корректно исполняться применяться механизм переключения между ними.

- ОС передает поток на исполнение ядру процессора.
- Этот поток исполняется в течение некоторого временного интервала.
- После завершения этого интервала контекст ОС переключается на другой поток.

_Переключение контекста_

 - обновляется контекст текущего потока
 - из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре
 - загружается контекст выбранного потока

Класс std::thread  применяется  для  управления  потоком  выполнения. В нем имеются средства для запуска нового потока и ожидания завершения потока, а также для идентификации потоков. Также в класс включены другие функции для управления потоком выполнения

Создание объекта типа std::thread запускает новый поток. До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach().
Конструктор thread первым аргументом принимает функцию исполнения, а остальные аргументы -
аргументы исполняемой функции. _Нельза_ передавать ссылки и указатели на объекты, время
жизни которых меньше, чем время жизни потока. Thread копирует аргументы, а потом передает
их исполняемой функции. (Если функция принимает ссылку, то это будет не та ссылка, которую
вы передали в конструкторе. Использовать функцию std::ref)

После создания объекта thread возможны три варианта:
- Пользователь выполнил thread.join(). Вызов метода join приведет к ожиданию завершения потока. Это значит, что до тех пор пока поток не завершит своё выполнение, основной поток не будет выполнять код находящийся после вызова метода join(). Этот метод необходимо использовать, если основному потоку необходим и важен результат выполнения дочернего потока.
- Пользователь выполнил thread.detach(). Пользователя не интересует судьба созданного потока и главный
потомк исполнения может завершится до того, как будет завершен созданный поток. НЕ блокирует вызывающий поток.
- Если ничего не было выполнено пользователем - выдастся исключение.

Бывают моменты, когда необходимо узнать, в каком потоке исполнения вы находитесь.  Этот id может быть получен из объекта thread с помощью метода get_id.
```cpp
std::cout << "New thread id: 0x" << std::hex << thread.get_id() << "\n";
```

- sleep_until – поток приостанавливает выполнение до наступления момента, переданного в качестве аргумента.
- sleep_for – поток приостанавливает выполнение на некий, заданный промежуток времени.
```cpp
auto days = std::chrono::system_clock::now() + std::chrono::hours(72);
std::this_thread::sleep_until(days);
std::this_thread::sleep_for(std::chrono::hours(72));
//Обе функции кладут поток в сон на 3 дня.
```
##### Пример
```cpp
#include <iostream>
#include <thread>
#include <string>

     void func (std::string first,std::string second)
     {
         std::cout << first << second;
     };

int main()
{
    std::thread thread(func, "Hello, ", "threads!");
    thread.join();
}
```

Переменная, объявленная с описанием _thread_local_ , доступна только в потоке, в котором он создан.
Переменная создается при создании потока и уничтожается при его уничтожении. Каждый поток имеет свою
собственную копию переменной

```cpp
thread_local int i=0;

void f(int newval){
    i=newval;
}

void g(){
    std::cout<<i;
}

void threadfunc(int id){
    f(id);
    ++i;
    g();
}

int main(){
    i=9;
    std::thread t1(threadfunc,1);
    std::thread t2(threadfunc,2);
    std::thread t3(threadfunc,3);

    t1.join();
    t2.join();
    t3.join();
    std::cout<<i<<std::endl;
}  // код будет выводить «2349», «3249», «4239», «4329», «2439»; или "3429", но больше ничего
```


#### 21 Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
---
_Гонка за данными_

Иногда при работе с несколькими потоками или процессами появляется необходимость синхронизировать выполнениедвух или более из них. Причина этого чаще всего заключается в том, что два или более потоков могут требовать доступ к разделяемому ресурсу, которыйреальноне может быть предоставлен сразу нескольким потокам. Разделяемым называется ресурс, доступ к которому могут одновременно получать несколько выполняющихся задач.
Механизм, обеспечивающий процесс синхронизации, называется ограничением доступа.Необходимость в нем возникает также в тех случаях, когда один поток ожидает события, генерируемого другим потоком. Естественно, должен существовать какой-то способ, с помощью которого первой поток будет приостановлен до совершения события. После этого поток должен продолжить свое выполнение.

_Устранение гонок_

Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.
Мьютексы - наиболее общий механизм защиты данных в С++.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex g_lock;

void threadFunction()
{
     g_lock.lock();

     std::cout << "entered thread " << std::this_thread::get_id() << std::endl;

     g_lock.unlock();
}

int main()
{
     std::thread t1(threadFunction);
     std::thread t2(threadFunction);
     std::thread t3(threadFunction);
     t1.join();
     t2.join();
     t3.join();
     return 0;
}
```
Перед обращением к общим данным, мьютекс должен быть заблокирован методом lock, а после окончания работы с общими данными — разблокирован методом unlock.
Функция _lock_:
- Если mutex в настоящее время не заблокирован ни одним потоком, вызывающий поток блокирует его
- Если mutex  в настоящее время заблокирован тем же потоком, вызывающим эту функцию, он вызывает взаимоблокировку (с неопределенным поведением)
- Если mutex в  настоящее время заблокирован другим потоком, выполнение вызывающего потока блокируется, пока другой поток не будет разблокирован

Функция _try_lock_:
- Если mutex в настоящее время не заблокирован ни одним потоком, вызывающий поток блокирует его
- Если mutex в данный момент заблокирован другим потоком, функция завершается ошибкой и возвращается false без блокировки
- Если mutex настоящее время заблокирован тем же потоком, вызывающим эту функцию, он вызывает взаимоблокировку

Функция _unlock_:
- Разблокирует mutex, освободив право собственности на него.

lock_guard - это реализация принципа RAII для mutex. При создании lock_guard захватывается
mutex, переданный ему в конструкторе. В деструкторе же происходит его освобождение.
##### Пример
```cpp
#include <thread>
#include <mutex>
#include <iostream>

int g_i = 0;
std::mutex g_i_mutex;  // protects g_i

void safe_increment()
{
    const std::lock_guard<std::mutex> lock(g_i_mutex);
    ++g_i;

    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';

    // g_i_mutex is automatically released when lock
    // goes out of scope
}

int main()
{
    std::cout << "main: " << g_i << '\n';

    std::thread t1(safe_increment);
    std::thread t2(safe_increment);

    t1.join();
    t2.join();

    std::cout << "main: " << g_i << '\n';
}
```
Класс std::unique_lock обладает большей гибкостью, чем std::lock_guard.

_unique_lock может_:
- принимать не захваченные mutex в конструкторе
- захватывать и освобождать mutex неоспредственно lock/unlock/try_lock
- выполнять временной захвата
- может быть перемещен в другой объект unique_lock

То есть unique_lock может быть использован в любом контексте, в котором может быть использован
"голый" mutex, гарантируя, при этом, что захваченный mutex будет освобожден в деструкторе.

##### Пример
```cpp
    // unique_lock::operator= example
    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex, std::unique_lock

    std::mutex mtx;           // mutex for critical section

    void print_fifty (char c) {
      std::unique_lock<std::mutex> lck;         // default-constructed
      lck = std::unique_lock<std::mutex>(mtx);  // move-assigned
      for (int i=0; i<50; ++i) { std::cout << c; }
      std::cout << '\n';
    }

    int main ()
    {
      std::thread th1 (print_fifty,'*');
      std::thread th2 (print_fifty,'$');

      th1.join();
      th2.join();

      return 0;
    }
```

В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.
##### Пример
```cpp
    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex, std::lock

    std::mutex foo,bar;

    void task_a () {
      // foo.lock(); bar.lock(); // replaced by:
      std::lock (foo,bar);
      std::cout << "task a\n";
      foo.unlock();
      bar.unlock();
    }

    void task_b () {
      // bar.lock(); foo.lock(); // replaced by:
      std::lock (bar,foo);
      std::cout << "task b\n";
      bar.unlock();
      foo.unlock();
    }

    int main ()
    {
      std::thread th1 (task_a);
      std::thread th2 (task_b);

      th1.join();
      th2.join();

      return 0;
    } // task a  task b
```
#### 22. Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock.
---
_Гонка за данными_

Иногда при работе с несколькими потоками или процессами появляется необходимость синхронизировать выполнениедвух или более из них. Причина этого чаще всего заключается в том, что два или более потоков могут требовать доступ к разделяемому ресурсу, которыйреальноне может быть предоставлен сразу нескольким потокам. Разделяемым называется ресурс, доступ к которому могут одновременно получать несколько выполняющихся задач.
Механизм, обеспечивающий процесс синхронизации, называется ограничением доступа.Необходимость в нем возникает также в тех случаях, когда один поток ожидает события, генерируемого другим потоком. Естественно, должен существовать какой-то способ, с помощью которого первой поток будет приостановлен до совершения события. После этого поток должен продолжить свое выполнение.

_Устранение гонок_

Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

Мьютексы - наиболее общий механизм защиты данных в С++.

Класс std::unique_lock обладает большей гибкостью, чем std::lock_guard.

_unique_lock может_:
- принимать не захваченные mutex в конструкторе
- захватывать и освобождать mutex неоспредственно lock/unlock/try_lock
- выполнять временной захвата
- может быть перемещен в другой объект unique_lock

То есть unique_lock может быть использован в любом контексте, в котором может быть использован
"голый" mutex, гарантируя, при этом, что захваченный mutex будет освобожден в деструкторе.

##### Пример
```cpp
    // unique_lock::operator= example
    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex, std::unique_lock

    std::mutex mtx;           // mutex for critical section

    void print_fifty (char c) {
      std::unique_lock<std::mutex> lck;         // default-constructed
      lck = std::unique_lock<std::mutex>(mtx);  // move-assigned
      for (int i=0; i<50; ++i) { std::cout << c; }
      std::cout << '\n';
    }

    int main ()
    {
      std::thread th1 (print_fifty,'*');
      std::thread th2 (print_fifty,'$');

      th1.join();
      th2.join();

      return 0;
    }
```


Класс std::recursive_mutex, который  может блокировать более одного раза одним и тем же потоком, придется вызывать unlock столько раз, сколько вызывался lock, чтобы его разблокировать(для обычного mutex его повторное блокирование приведет к неопределенному поведению)
Перед обращением к общим данным, recursive_mutex должен быть заблокирован методом lock, а после окончания работы с общими данными — разблокирован методом unlock.
Функция _lock_:
- Если mutex в настоящее время не заблокирован ни одним потоком, вызывающий поток блокирует его
- Если mutex  в настоящее время заблокирован тем же потоком, вызывающим эту функцию, он приобретает новый уровень владения над recursive_mutex. ЕГо разблокировка потребует такого же количества unlock.
- Если mutex в  настоящее время заблокирован другим потоком, выполнение вызывающего потока блокируется, пока другой поток не будет разблокирован

Функция _try_lock_:
- Если mutex в настоящее время не заблокирован ни одним потоком, вызывающий поток блокирует его
- Если mutex в данный момент заблокирован другим потоком, функция завершается ошибкой и возвращается false без блокировки
- Если mutex в  настоящее время заблокирован другим потоком, выполнение вызывающего потока блокируется, пока другой поток не будет разблокирован

Функция _unlock_:
- Разблокирует mutex, освободив право собственности на него.

##### Пример
```cpp
#include <iostream>
#include <mutex>

int main()
{
    std::recursive_mutex test;
    if (test.try_lock()==true) {
        std::cout << "lock acquired" << std::endl;
        test.unlock();	//now unlock the mutex
    } else {
        std::cout << "lock not acquired" << std::endl;
    }

    test.lock();	//to lock it again
    if (test.try_lock()) {  //true can be left out
        std::cout << "lock acquired" << std::endl;
    } else {
        std::cout << "lock not acquired" << std::endl;
    }
    test.unlock();
}  // lock acquired   lock not acquired
```
В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.
##### Пример
```cpp
    #include <iostream>       // std::cout
    #include <thread>         // std::thread
    #include <mutex>          // std::mutex, std::lock

    std::mutex foo,bar;

    void task_a () {
      // foo.lock(); bar.lock(); // replaced by:
      std::lock (foo,bar);
      std::cout << "task a\n";
      foo.unlock();
      bar.unlock();
    }

    void task_b () {
      // bar.lock(); foo.lock(); // replaced by:
      std::lock (bar,foo);
      std::cout << "task b\n";
      bar.unlock();
      foo.unlock();
    }

    int main ()
    {
      std::thread th1 (task_a);
      std::thread th2 (task_b);

      th1.join();
      th2.join();

      return 0;
    } // task a  task b
```
_shared_mutex_ является примитивом синхронизации, который может использоваться для защиты общих данных от одновременного доступа нескольких потоков. Этот мьютекс позволяет
одновременно многим потокам читать одни и те же данные, если в этот момент нет потоков, изменяющих
эти данные. Если много читателей долго удерживают блокировку, было видно преимущество в скорости,
но при коротких чтениях shared_mutex замедлял работу программы (за счет атомарных счетчиков). В отличие от других типов мьютексов, которые облегчают монопольный доступ, shared_mutex имеет два уровня доступа:
- общий доступ - несколько потоков могут совместно владеть одним и тем же мьютексом.
- исключительный - только один поток может владеть мьютексом.
Если один поток получил исключительную блокировку (через блокировку , try_lock ), никакие другие потоки не могут получить блокировку (включая общую ).

Если один поток получил общую блокировку (через lock_shared , try_lock_shared ), никакой другой поток не может получить эксклюзивную блокировку, но может получить общую блокировку.

Только когда исключительная блокировка не была получена каким-либо потоком, общая блокировка может быть получена несколькими потоками.

В пределах одного потока одновременно может быть получена только одна блокировка ( общая или исключительная ).

Общие мьютексы обычно используются в ситуациях, когда несколько читателей могут получить доступ к одному и тому же ресурсу одновременно, не вызывая гонки данных, но это может сделать только один писатель.

##### Пример
```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>

int value = 0;
std::shared_mutex mutex;

// Reads the value and sets v to that value
void readValue(int& v) {
  mutex.lock_shared();
  v = value;
  mutex.unlock_shared();
}

// Sets value to v
void setValue(int v) {
  mutex.lock();
  value = v;
  mutex.unlock();
}

int main() {
  int read1;
  int read2;
  int read3;
  std::thread t1(readValue, std::ref(read1));
  std::thread t2(readValue, std::ref(read2));
  std::thread t3(readValue, std::ref(read3));
  std::thread t4(setValue, 1);

  t1.join();
  t2.join();
  t3.join();
  t4.join();

}
```


#### 23. Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
---
_condition_variable_ - еще один блокирующий примитив. Привычным шаблоном использования подобного примитива
является ожидание одого понтока, наступления события в другом потоке. Можете думать об этом
примитиве как о неком сигнале, появления которого необходимо ожидать.

- wait – ставит поток в ожидание сигнала. Ожидание не лимитировано временем. Может принимать в качестве аргумента предикат, от результата которого будет зависеть выход потока из ожидания. Т.е. если даже wait был завершен благодаря сигналу, происходит проверка предиката после чего поток снова становится в ожидание, если предикат ложен.
- wait_for – Ожидание лимитировано согласно аргументу
- wait_until - Ожидание лимитировано согласно аргументу
- notify_one – Посылает сигнал одному из ожидающих потоков; т.е. разблокирует один поток. Какой поток будет разбужен – не известно. Гарантировано лишь то, что один из них будет.
- notify_all – Посылает сигнал всем ожидающим потокам; т.е. разблокирует все потоки ожидающие на данном объекте condition_variable

condition_variable не является самостоятельным примитивом, т.к. wait происходит на объекте std::unique_lock. При этом unique_lock должен быть захвачен перед тем как будет передан в функцию wait. Более того, вы должны гарантировать, что все wait, для данного объекта condition_variable, выполнены на одном и том же мьютексе.

##### Пример
```cpp
#include <iostream>           // std::cout
#include <thread>             // std::thread
#include <mutex>              // std::mutex, std::unique_lock
#include <condition_variable> // std::condition_variable

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_id (int id) {
  std::unique_lock<std::mutex> lck(mtx);
  while (!ready) cv.wait(lck);
  // ...
  std::cout << "thread " << id << '\n';
}

void go() {
  std::unique_lock<std::mutex> lck(mtx);
  ready = true;
  cv.notify_all();
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(print_id,i);

  std::cout << "10 threads ready to race...\n";
  go();                       // go!

  for (auto& th : threads) th.join();

  return 0;
}
```
Код потокобезопасный, если он функционирует корректно при использовании нескольких отокпов
одновременно.

Структура данных безопасна при выполнении следующих аспектов:
‒ уверенность, что ни один поток не может увидеть состояние
нарушение инвариантности структуры данных со стороны других потоков;
‒ предотвращение состояний гонок, которые присущи всем
структурам данных, путем предоставления функций, которые должны
выполнять операции целиком, а не частями;
‒ минимизивароние шансов возникновения взаимоблокировки за счет
ограничения области действия блокировок и отсутствия внутренних блокировок;
‒ при наличии исключений не допускать нарушения инвариантов

Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке.

Проектирование  параллельных  структур  данных  с  блокировками  сводится  к  тому,  чтобы  захватить  нужный  мьютекс  при  доступе  к  данным и удерживать его минимально возможное время.

#### 24. Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable.
---
 _Гонка за данными_

 Иногда при работе с несколькими потоками или процессами появляется необходимость синхронизировать выполнениедвух или более из них. Причина этого чаще всего заключается в том, что два или более потоков могут требовать доступ к разделяемому ресурсу, которыйреальноне может быть предоставлен сразу нескольким потокам. Разделяемым называется ресурс, доступ к которому могут одновременно получать несколько выполняющихся задач.
 Механизм, обеспечивающий процесс синхронизации, называется ограничением доступа.Необходимость в нем возникает также в тех случаях, когда один поток ожидает события, генерируемого другим потоком. Естественно, должен существовать какой-то способ, с помощью которого первой поток будет приостановлен до совершения события. После этого поток должен продолжить свое выполнение.

 _Устранение гонок_

 Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
 Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

 Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

 Мьютексы - наиболее общий механизм защиты данных в С++.

_Пул потоков_

В простейшем случае пул состоит из  фиксированного числа рабочих потоков  (обычно  равного  значению,  которое  возвращает  функция std::thread::hardware_concurrency()).  Когда  у  программы  по-является  какая-то  работа,  она  вызывает  функцию,  которая  помеща-ет  эту  работу  в  очередь.  Рабочий  поток  забирает  работу  из  очереди,  выполняет  указанную  в  ней  задачу,  после  чего  проверяет,  есть  ли  в  очереди другие работы.

_condition_variable_ - еще один блокирующий примитив. Привычным шаблоном использования подобного примитива
является ожидание одого понтока, наступления события в другом потоке. Можете думать об этом
примитиве как о неком сигнале, появления которого необходимо ожидать.

- wait – ставит поток в ожидание сигнала. Ожидание не лимитировано временем. Может принимать в качестве аргумента предикат, от результата которого будет зависеть выход потока из ожидания. Т.е. если даже wait был завершен благодаря сигналу, происходит проверка предиката после чего поток снова становится в ожидание, если предикат ложен. На псевдокоде: (while(!predicate) wait;). А нужно это, в первую очередь, для того, чтобы избежать реагирования на фальшивое(spurious) пробуждение(см. врезку ниже).
- wait_for – Ожидание лимитировано согласно аргументу
- wait_until - Ожидание лимитировано согласно аргументу
- notify_one – Посылает сигнал одному из ожидающих потоков; т.е. разблокирует один поток. Какой поток будет разбужен – не известно. Гарантировано лишь то, что один из них будет.
- notify_all – Посылает сигнал всем ожидающим потокам; т.е. разблокирует все потоки ожидающие на данном объекте condition_variable

condition_variable не является самостоятельным примитивом, т.к. wait происходит на объекте std::unique_lock. При этом unique_lock должен быть захвачен перед тем как будет передан в функцию wait. Более того, вы должны гарантировать, что все wait, для данного объекта condition_variable, выполнены на одном и том же мьютексе.

##### Пример
```cpp
#include <iostream>           // std::cout
#include <thread>             // std::thread
#include <mutex>              // std::mutex, std::unique_lock
#include <condition_variable> // std::condition_variable

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_id (int id) {
  std::unique_lock<std::mutex> lck(mtx);
  while (!ready) cv.wait(lck);
  // ...
  std::cout << "thread " << id << '\n';
}

void go() {
  std::unique_lock<std::mutex> lck(mtx);
  ready = true;
  cv.notify_all();
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(print_id,i);

  std::cout << "10 threads ready to race...\n";
  go();                       // go!

  for (auto& th : threads) th.join();

  return 0;
}
```

#### 25. Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future,функция std::async
---
_Гонка за данными_

 Иногда при работе с несколькими потоками или процессами появляется необходимость синхронизировать выполнениедвух или более из них. Причина этого чаще всего заключается в том, что два или более потоков могут требовать доступ к разделяемому ресурсу, которыйреальноне может быть предоставлен сразу нескольким потокам. Разделяемым называется ресурс, доступ к которому могут одновременно получать несколько выполняющихся задач.
 Механизм, обеспечивающий процесс синхронизации, называется ограничением доступа.Необходимость в нем возникает также в тех случаях, когда один поток ожидает события, генерируемого другим потоком. Естественно, должен существовать какой-то способ, с помощью которого первой поток будет приостановлен до совершения события. После этого поток должен продолжить свое выполнение.

 _Устранение гонок_

 Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
 Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

 Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.
Состояния гонок в интерфейсе стурктур данных - гонки, возникающие при обращении к объекту, в ходе которых нарушаются его инварианты. Инвариант - некое условие, выполнение которого необходимо для правильной работы струтктуры. К примеру поле size класса vector хранит количество элементов в массиве. Если это не так (допустим, произошла ошибка доступа к соотвествующему объекту и поле было изменено некорректно), то инвариант нарушен. Помимо этого Вильямс упоминает, что методы доступа и получения информации о структурах нельзя считать валидными, поскольку данные, полученные с помощью этих методов, были правильными лишь в момент их получения. То есть, после их получения и перед использованием данные могут быть изменены другим потоком.

Класс _std::future_ представляет собой некую обертку , над каким-либо значением или объектом,
вычисление или получение которого происходит отложено. Точнее, future предоставляет доступ к некоторому
разделяемому состоянию, которое состоит из двух частей: данные(здесь лежит значение) и флаг готовности.
Future является получателем значения и не может самостотельно выставлять его, роль future пассивна.
Появление или вычисление значения, означает, что разделяемое состояние содержит требуемое значене и флаг готовнссти
поднят, значит значение может быть изъято в любое время без блокировок. Объект future предоставляет
исключительный доступ к значению, когда оно было вычислено. Объект future не может быть скопирован,
а может быть только перемещен.
Для получения значения future предназначен метод _std::future::get_ ,но его вызов обязан быть однократным (в противном случае - неопределенное поведение)
При этом поток, вызвавший get
блокируется до вычисления значения. Именно поэтому и говориться об отложенном получении, ведь поток,
получивший объект может не сразу блокироваться в нём, для получения значения, а делать всё, что
угодно, пока не станет необходимо получить значение. Можно просто подождать значения без его получения
функция _std::future::wait_. std::future имеет метод valid, позволяющий проверить был ли получен результат.

##### Пример
```cpp
#include <iostream>
#include <future>

std::future<bool> submitForm(const std::string& form);

int main()
{
    auto check = submitForm("my form");
    if(check.get())
        std::cout << "Wow I've got a passport!\n";
    else
        std::cout << "Dammit, they found a mistake again!\n";
}
```

Еще одним методом получения future является функция _std::async_. Она принимает в качестве аргументов
функцию, аргументы функции и , оптимально, флаг, который влияет на политику вызова
async. Возвращаемым значением async является future, значение которого будет выставлено по возвращении
функции.
Поведение _std::async_ зависит от переданных флагов:
- launch::async – если передан этот флаг, то поведение async будет следующим: будет создан объект класса thread, с функцией и её аргументами в качестве аргументов нового потока. Т.е. async инкапсулирует  создание потока, получение future и предоставляет однострочную запись для выполнения такого кода
- launch::deferred – если передан этот флаг, то имя функции async становится несколько не логичным. Т.к. никакого асинхронного вызова не произойдёт. Вместо исполнения функции в новом потоке, она, вместе с аргументами, будет сохранена в future(еще одна особенность future), чтобы быть вызванными позже. Это позже наступит тогда, когда кто-либо вызовет метод get(или wait, но не wait_for!) на future, которое вернул async. При этот вызываемый объект выполнится в потоке, который вызывал get! Это поведение есть ни что иное, как отложенный вызов процедуры.
- launch::async | launch::deferred  - в этом случае будет выбрано одно из двух поведений описанных выше. Какое из двух? Неизвестно и зависит от имплементации.

##### Cтруктурный пример
```cpp

#include <iostream>
#include <future>

int Foo()
{
    int res;
    // Что-то долго делаем и возвращаем результат
    retrun res;
}

std::future<int> f = std::async(std::launch::async, Foo);
// Работаем дальше в основном потоке

// Когда нам нужно, получаем результат работы Foo
auto x = f.get();
```

##### Пример
```cpp
#include <iostream>       // std::cout
#include <future>         // std::async, std::future

// a non-optimized way of checking for prime numbers:
bool is_prime (int x) {
  std::cout << "Calculating. Please, wait...\n";
  for (int i=2; i<x; ++i) if (x%i==0) return false;
  return true;
}

int main ()
{
  // call is_prime(313222313) asynchronously:
  std::future<bool> fut = std::async (is_prime,313222313);

  std::cout << "Checking whether 313222313 is prime.\n";

  bool ret = fut.get();      // waits for is_prime to return

  if (ret) std::cout << "It is prime!\n";
  else std::cout << "It is not prime.\n";

  return 0;
}
```

#### 26. Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic. Структуры данных без блокировок. Рeализация lock-free stack.
---
Под атомарными понимаются неделимые операции. Ни из одного потока в системе невозможно увидеть, что такая операция выполнена наполовину – она либо выполнена целиком, либо не выполнена вовсе. Если операция загрузки, которая читает значение объекта, атомарна, и все операции модификации этого объекта также атомарны, то в результате загрузки будет получено либо начальное значение объекта, либо значение, сохраненное в нем после одной из модификаций.
Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент. Примерами
является инкремент, чтение,запись и т.д.
Всё, что ограждено mutex можно считать атомарной операцией, так как никто не может попасть в блок,
огражденный mutex, но это довольно неэффективно и небезопасно.
Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.
_std::atomic<T>_ имеет базовые операции:
- is_lock_free (проверяет, не заблокированы атомарные операции со всеми объектами этого типа)
- store или operator=() (кладет новое значение в объект)
- load или operator T() (извлекает значение из объекта)
- exchange (заменяет значение в объекте на новое и возвращает старое)
##### Реализация is_lock_free
```cpp
#include <iostream>
#include <utility>
#include <atomic>

struct A { int a[100]; };
struct B { int x, y; };
int main()
{
    std::cout << std::boolalpha
              << "std::atomic<A> is lock free? "
              << std::atomic<A>{}.is_lock_free() << '\n' //false
              << "std::atomic<B> is lock free? "
              << std::atomic<B>{}.is_lock_free() << '\n'; //true
}
```
_std::atomic<integral>_ включает в себя все интегральные типы, существующие в С++
(char, int, long, short и их разные формы)

Дополнительные операции:
- fetch_add(object, value) – атомарно помещает сумму (object + value) в object.
- fetch_sub(object, value) – атомарно помещает (object – value) в object.
- fetch_and(object, value) – атомарно помещает (object & value) в object.
- fetch_or(object, value) – атомарно помещает (object | value) в object.
- fetch_xor(object, value) – атомарно помещает (object ^ value) в object.

##### Реализация fetch_add
```cpp
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<long long> data;
void do_work()
{
    data.fetch_add(1);
}

int main()
{
    std::thread th1(do_work);
    std::thread th2(do_work);
    std::thread th3(do_work);
    std::thread th4(do_work);
    std::thread th5(do_work);

    th1.join();
    th2.join();
    th3.join();
    th4.join();
    th5.join();

    std::cout << "Result:" << data << '\n'; // 5
}
```
##### Общий пример
```cpp
#include <iostream>       // std::cout
#include <atomic>         // std::atomic, std::atomic_flag, ATOMIC_FLAG_INIT
#include <thread>         // std::thread, std::this_thread::yield
#include <vector>         // std::vector

std::atomic<bool> ready (false);
std::atomic_flag winner = ATOMIC_FLAG_INIT;

void count1m (int id) {
  while (!ready) { std::this_thread::yield(); }      // wait for the ready signal
  for (volatile int i=0; i<1000000; ++i) {}          // go!, count to 1 million
  if (!winner.test_and_set()) { std::cout << "thread #" << id << " won!\n"; }
};

int main ()
{
  std::vector<std::thread> threads;
  std::cout << "spawning 10 threads that count to 1 million...\n";
  for (int i=1; i<=10; ++i) threads.push_back(std::thread(count1m,i));
  ready = true;
  for (auto& th : threads) th.join();

  return 0;
}
```

```std::atomic_flag``` - простейший атомарный объект, представляющий собой булев флаг. Он единственный
_гарантировано_ является свободным от блокировок, то есть по стандарту все операции над объектом
типа atomic_flag являются чисто атомарными, без каких-то условностей.
_atomic_flag_ содержит всего две операции:
- clear (атомарно устанавливает флаг на false)
- test_and_set (атомарно устанавливает флаг на true и возвращает начальное состояние флага)

Важным свойством atomic_flag является неопределенность при создании, то есть стандарт не оговаривает
в каком состоянии находится флаг, ежели он не инициализирован. Поэтому, для получения предсказуемого результата
есть смысл всегда инициализировать флаг с помощью макроса ATOMIC_FLAG_INIT (тогда он _гарантировано
станет сброшенным)
##### ИНициализация флага
```cpp
std::atomic_flag flag = ATOMIC_FLAG_INIT;
```

##### Пример  ```std::atomic_flag```:
```cpp
#include <iostream>       // std::cout
#include <atomic>         // std::atomic_flag
#include <thread>         // std::thread
#include <vector>         // std::vector
#include <sstream>        // std::stringstream

std::atomic_flag lock_stream = ATOMIC_FLAG_INIT;
std::stringstream stream;

void append_number(int x) {
  while (lock_stream.test_and_set()) {} //возвращет прежнее значение false, означающее
  stream << "thread #" << x << '\n';    //что в это потоке значение флага установлено true
  lock_stream.clear();
}

int main ()
{
  std::vector<std::thread> threads;
  for (int i=1; i<=10; ++i) threads.push_back(std::thread(append_number,i));
  for (auto& th : threads) th.join();

  std::cout << stream.str();
  return 0;
}
```
Чтобы структура данных считалась свободной от блокировок, она должна быть открыта для одновременного
доступа со стороны сразу нескольких потоков. Не требуется, чтобы потоки могли выполнять одну и ту
же операцию, свободная от блокироки очередь может позволять одному потоку помещать,а
другому - извлекать данные, но запрещать одновременное добавление данных со стороны двух потоков.
Более того, если один из потоков, обращающихся к структуре данных, будет приостановлен планировщиком в середине
операции, то остальные должны иметь возможность завершить операцию, не дожидаясь возобновления
приостановленного потока. Одним из примеров структур данных без блокировки - atomic_flag и lock-free stack.

_Lock_free Stack_ или потокобезопасный стек без блокировок
Основное свойство стека - элементы извлекаются в порядке, обратном тому, в котором помещались,  то есть
последним пришел - первыйм ушел (LIFO). ВАжно убедиться, что после добавления значения в стек
оно может быть сразу же безопасно извлечено другим потоков, что только один поток получает значение.
Простейшая реализация стека основана на связном списке.

Схема добавления узла:
- создать новый узел
- записать в его указатель next текущее положение head
- записать head указатель на новый узел

Все это прекрасно работает с одним потоком, но, когдас стек могут модифицировать сразу несколько
потоков, этого недостаточно. ЕСли узлы добавляют два потока, то между шагами 2 и 3 возможна гонка.
Следует использовать атомарную операцию сравнить-и-обменять на шаге 3, гарантирующую, что head не был
модифицирован с момента чтения на шаге 2. Если был, то следует вернуться в начало цикла и покторить.

Схема извлечения узла:
- прочитать текущее значени head
- прочитать head->next
- записать в head значение head->next
- вернуть поле data, хранящееся в извлеченном узле node
- удалить извлеченый узел
НАличие нескольких потоков усложняет дело.

##### Реализация lock-free Stack
```cpp
template<typename T>
class lock_free_stack {
private:
 struct node
 {
    std::shared_ptr<T> data; //не возбуждает исключения, поэтому pop() безопасна
    node* next;
    node(T const& data_) : data(std::make_shared<T>(data)) //создаем shared_ptr для только что выделенного Т, выделяем память
    {}

 };

 std::atomic<node*> head;

 public:
  void push(T const& data) {
   node* const new_node = new node(data);
   new_node->next = head.load();
   while (!head.compare_exchange_weak(new_node->next, new_node));
  } //проверяет, что указатель head по прежнему содержит значени, которое было сохранено в new_node->next и если это так, то записывает его в new_node

   std::shared_ptr<T> pop()
   {
   node* old_head = head.load();
   while (old_head && !head.compare_exchange_weak(old_head, old_head->next)); //проверяем old_head на нуль
     return old_head ? old_head->data : std::shared_ptr<T>();
   } // возвращаем либо нудевой указатель, либо ассоциированные с узлом данные
};
```

#### 27. Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
---
Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.
Для обеспечения относительно простого добавления в систему новых типов паттерн Factory Method
локализирует создание объектнов конкретных типов в специальном классе-фабрике. МЕтоды этого класса,
посредством которых создаются объекты конкретных классв, называются фабричными.

![list4](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)
- Продукт определяет общий интерфейс объектов, которые может произвести создатель и его подклассы.
- Конкретные продукты содержат код различных продуктов. Продукты будут отличаться реализацией, но интерфейс у них будет общий.
- Создатель объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом продуктов. Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Но он может возвращать и некий стандартный продукт. Несмотря на название, важно понимать, что создание продуктов не является единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом.
- Конкретные создатели по-своему реализуют фабричный метод, производя те или иные конкретные продукты. Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.


Реализация Фабричного метода:
```cpp
class Warrior
{
  public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};

class Infantryman: public Warrior
{
  public:
    void info() {
      cout << "Infantryman" << endl;
    };
};

class Archer: public Warrior
{
  public:
    void info() {
      cout << "Archer" << endl;
    };
};

class Horseman: public Warrior
{
  public:
    void info() {
      cout << "Horseman" << endl;
    };
};

// Фабрики объектов
class Factory
{
  public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};

class InfantryFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Infantryman;
    }
};

class ArchersFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Archer;
    }
};

class CavalryFactory: public Factory
{
  public:
    Warrior* createWarrior() {
      return new Horseman;
    }
};


// Создание объектов при помощи фабрик объектов
int main()
{
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory*  archers_factory  = new ArchersFactory ;
    CavalryFactory*  cavalry_factory  = new CavalryFactory ;

    vector<Warrior*> v;
    v.push_back( infantry_factory->createWarrior());
    v.push_back( archers_factory->createWarrior());
    v.push_back( cavalry_factory->createWarrior());

    for(int i=0; i<v.size(); i++)
        v[i]->info();
    // ...
}
```

_Простая фабрика_ - это класс, в котором есть один метод с большим условным оператором,
выбирающим создаваемый продукт. Этот метод называется неким параметром, по которому определяется какой
из продуктов нужно создать. У простой фабрики обычно нет подклассов. Простая фабрика находится в шаге от того,
чтобы стать фабричным методом.
Простая фабрика предоставляет интерфейс для создание одного продукта. Отличие фабричного метода в
создании набора классов, создающих экземпляры - конкретные классы расширяют класс с
фабричным методом.

##### Пример (Не совсем точный)
```cpp
#include <vector>
#include <iostream>

class Horseman
{
  public:
    void info() {
      std::cout << "Horseman" << std::endl; };
};


class Factory
{
  public:
    Horseman* createWarrior()
    {
          return new Horseman;
    }
    virtual ~Factory() {}
};

// Создание объектов при помощи фабрик объектов
int main()
{
    Factory* myfactory = new Factory;
    std::vector<Horseman*> v;
    v.push_back()myfactory->createWarrior();

        v[0]->info();
}
```
#### 28. Шаблоны проектирования: observer. Пример реализации «обозреватель».
---
_Observer_ — поведенческий шаблон проектирования. Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними.
ПАттерн НАблюдатель включает в себя два компонента:
- источник
- наблюдатель
Количество наблюдателей одновременно взаимодействующих с источником не ограничено. ПРичем, в одному и
тому же источнику могут быть подключены объекты Наблюдатели как из одного класса, так и из
разных.

Шаблон «наблюдатель» применяется в тех случаях, когда система обладает следующими свойствами:
- существует, как минимум, один объект, рассылающий сообщения
- имеется не менее одного получателя сообщений, причём их количество и состав могут изменяться во время работы приложения
- нет надобности очень сильно связывать взаимодействующие объекты, что полезно для повторного использования.

Данный шаблон _часто применяют в ситуациях_, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией.

Реализация паттерна Observer по шагам:
- моделируйте "независимую" функциональность с помощью абстракции "субъект".
- Смоделируйте "зависимую" функциональность с помощью иерархии "наблюдатель".
- Класс Subject связан только c базовым классом Observer.
- Наблюдатели регистрируются у субъекта.
- Субъект извещает всех зарегистрированных наблюдателей.
- Наблюдатели "вытягивают" необходимую им информацию от объекта Subject.
- Клиент настраивает количество и типы наблюдателей.

##### Реализация
```cpp
#include <iostream>
#include <vector>
using namespace std;

// 1. "Независимая" функциональность
class Subject {
    // 3. Связь только базовым классом Observer
    vector < class Observer * > views;
    int value;
  public:
    void attach(Observer *obs) {
        views.push_back(obs);
    }
    void setVal(int val) {
        value = val;
        notify();
    }
    int getVal() {
        return value;
    }
    void notify();
};

// 2. "Зависимая" функциональность
class Observer {
    Subject *model;
    int denom;
  public:
    Observer(Subject *mod, int div) {
        model = mod;
        denom = div;
        // 4. Наблюдатели регистрируются у субъекта
        model->attach(this);
    }
    virtual void update() = 0;
  protected:
    Subject *getSubject() {
        return model;
    }
    int getDivisor() {
        return denom;
    }
};

void Subject::notify() {
  // 5. Извещение наблюдателей
  for (int i = 0; i < views.size(); i++)
    views[i]->update();
}

class DivObserver: public Observer {
  public:
    DivObserver(Subject *mod, int div): Observer(mod, div){}
    void update() {
        // 6. "Вытягивание" интересующей информации
        int v = getSubject()->getVal(), d = getDivisor();
        cout << v << " div " << d << " is " << v/d << '\n';
    }
};

class ModObserver: public Observer {
  public:
    ModObserver(Subject *mod, int div): Observer(mod, div){}
    void update() {
        int v = getSubject()->getVal(), d = getDivisor();
        cout << v << " mod " << d << " is " << v%d << '\n';
    }
};

int main() {
  Subject subj;
  DivObserver divObs1(&subj, 4); // 7. Клиент настраивает число и типы наблюдателей
  DivObserver divObs2(&subj, 3); //    и типы наблюдателей
  ModObserver modObs3(&subj, 3);
  subj.setVal(14);
}
```

#### 29. Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
---
_Асинхронное программирование_ (АП) - это форма параллельного программирования, которая позволяет структурной единице системы работать отдельно от основного потока приложения. Когда работа завершена, она уведомляет основной поток о том, была ли работа завершена или нет.

Плюсы и минусы асинхронного подхода:
- Безусловный плюс — это производительность. Причем она не просто в разы выше, она выше на порядки.
- Минус — сложный и запутанный код, который к тому же еще и сложно отлаживать.

Функция std::async  позволяет  запустить  асинхронную  зада-чу,  результат  которой  прямо  сейчас  не  нужен.  Но  вместо  объекта  std::thread  она  возвращает  объект  std::future  ,  который  будет  содержать возвращенное значение, когда оно станет доступно. Когда программе понадобится значение, она вызовет функцию-член get()объекта-будущего, и тогда поток будет приостановлен до готовности будущего  результата,  после  чего  вернет  значение.

Она принимает в качестве аргументов
функцию, аргументы функции и , оптимально, флаг, который влияет на политику вызова
async. Возвращаемым значением async является future, значение которого будет выставлено по возвращении
функции.
Поведение _std::async_ зависит от переданных флагов:
- launch::async – если передан этот флаг, то поведение async будет следующим: будет создан объект класса thread, с функцией и её аргументами в качестве аргументов нового потока. Т.е. async инкапсулирует  создание потока, получение future и предоставляет однострочную запись для выполнения такого кода
- launch::deferred – если передан этот флаг, то имя функции async становится несколько не логичным. Т.к. никакого асинхронного вызова не произойдёт. Вместо исполнения функции в новом потоке, она, вместе с аргументами, будет сохранена в future(еще одна особенность future), чтобы быть вызванными позже. Это позже наступит тогда, когда кто-либо вызовет метод get(или wait, но не wait_for!) на future, которое вернул async. При этот вызываемый объект выполнится в потоке, который вызывал get! Это поведение есть ни что иное, как отложенный вызов процедуры.
- launch::async | launch::deferred  - в этом случае будет выбрано одно из двух поведений описанных выше. Какое из двух? Неизвестно и зависит от имплементации.

##### Cтруктурный пример
```cpp

#include <iostream>
#include <future>

int Foo()
{
    int res;
    // Что-то долго делаем и возвращаем результат
    retrun res;
}

std::future<int> f = std::async(std::launch::async, Foo);
// Работаем дальше в основном потоке

// Когда нам нужно, получаем результат работы Foo
auto x = f.get();
```

##### Пример
```cpp
#include <iostream>       // std::cout
#include <future>         // std::async, std::future

// a non-optimized way of checking for prime numbers:
bool is_prime (int x) {
  std::cout << "Calculating. Please, wait...\n";
  for (int i=2; i<x; ++i) if (x%i==0) return false;
  return true;
}

int main ()
{
  // call is_prime(313222313) asynchronously:
  std::future<bool> fut = std::async (is_prime,313222313);

  std::cout << "Checking whether 313222313 is prime.\n";

  bool ret = fut.get();      // waits for is_prime to return

  if (ret) std::cout << "It is prime!\n";
  else std::cout << "It is not prime.\n";

  return 0;
}
```


_Cопрограммы_  — методика связи программных модулей друг с другом по принципу кооперативной многозадачности
Поток исполнения кода - это последовательность операций, которые выполняются друг за другом. В нужные моменты эта последовательность может быть приостановлена, и вместо нее может начать выполняться часть другой последовательности операций. В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), сопрограммы переключаются вручную, в местах, указанных программистом (кооперативная многозадачность).
Некоторые API инициируют долго протекающие операции (такие как сетевой ввод-вывод, файловый ввод-вывод, интенсивная обработка на CPU или GPU и др.), которые требуют блокировки вызывающего кода в ожидании завершения операций. Сопрограммы обеспечивают возможность избежать блокировки исполняющегося потока путём использования более дешёвой и управляемой операции: приостановки (suspend) сопрограммы (_СУТЬ_)модуль приостанавливается в определённой точке, сохраняя полное состояние (включая стек вызовов и счётчик команд), и передаёт управление другому. Тот, в свою очередь, выполняет задачу и передаёт управление обратно, сохраняя свои стек и счётчик.
Сопрограммы упрощают асинхронное программирование, оставив все осложнения внутри библиотек. Логика программы может быть выражена последовательно в сопрограммах, а базовая библиотека будет её реализовывать асинхронно для нас. Библиотека может обернуть соответствующие части кода пользователя в обратные вызовы (callbacks), подписывающиеся на соответствующие события, и диспетчировать исполнение на различные потоки (или даже на разные машины!). Код при этом останется столь же простой, как если бы исполнялся строго последовательно.

Обозначим операции над сопрограммой следующим образом:
```cpp
handle = spawn(СП); - запуск сопрограммы,
yield; - приостановка текущей сопрограммы,
resume(handle); - возобновление сопрограммы.
```

Возьмем две сопрограммы:
```cpp
// СП1      |  // СП2
{           |  {
  f1();     |     g1();
  f2();     |     yield;
  yield;    |     g2();
  f3();     |     g3();
  f4();     |     yield;
  yield;    |     g4();
  f5();     |     g5();
}           |  }

```
Тогда, если на одном системном потоке запустить СП1, а затем СП2, то системный поток выполнит операции в следующем детерминированном порядке:

```cpp
// Системный поток  |  Выполняемый код
c1 = spawn(СП1);    |  f1();
                    |  f2();
c2 = spawn(СП2);    |       g1();
resume(c1);         |  f3();
                    |  f4();
resume(c2);         |       g2();
                    |       g3();
resume(c1);         |  f5();
resume(c2);         |       g4();
                    |       g5();

```
В _С++ сопрограммой называется функция_, в которой используются co_await, co_yield, co_return.
- _co_await_ для приостановки выполнения до возобновления
- _слово co_yield_, чтобы приостановить выполнение, возвращающее значение
- _co_return_ для завершения выполнения, возвращая значение
```cpp
Future coroutine(X x) {
Y y = co_await f(x);
co_return y;
}
```
Компилятор переписывает тело сопрограммы, превращая ее в машину состояний.
Под данные сопрограммы выделяется память при помощи оператора new.
```cpp
Future coroutine(X x) {
struct CoroutineState {
Future::promise_type p;
X x;
Y y;
int state = 0;

void run() {
switch (state) {
case 0:
...
state = 1; // приостановка
return;
case 1: // точка возобновления
...
};
}
};
auto* s = new CoroutineState;
auto result = s->p.get_return_object();
s->x = x;
s->run();
return result;
}
```
При этом, хотя тело сопрограммы изменяется, она остается функцией


_Функция обратного вызова_ - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.
Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове. Этот код может быть определён в других контекстах программного кода и быть недоступным для прямого вызова из этой функции. Некоторые алгоритмические задачи в качестве своих входных данных имеют не только числа или объекты, но и действия (алгоритмы), которые естественным образом задаются как обратные вызовы.
Функции обратного вызова часто используются для продолжения выполнения кода после завершения асинхронной операции - они называются асинхронными обратными вызовами.

```cpp
/* The calling function takes a single callback as a parameter. */
void PrintTwoNumbers(int (*numberSource)(void)) {
    int val1 = numberSource();
    int val2 = numberSource();
    printf("%d and %d\n", val1, val2);
}

/* A possible callback */
int overNineThousand(void) {
    return (rand()%1000) + 9001;
}

/* Another possible callback. */
int meaningOfLife(void) {
    return 42;
}

/* Here we call PrintTwoNumbers() with three different callbacks. */
int main(void) {
    PrintTwoNumbers(&overNineThousand);
    PrintTwoNumbers(&meaningOfLife);
    return 0;
}
```

#### 30. Шаблоны проектирования: синглтон. Пример реализации Синглтона.
---
Шаблон синглтон предоставляет возможность создавать единственный экземпляр некоторого типа(класса),
предоставлять к нему доступ извне и запрещать создание нескольких экземпляров этого типа.
Контроль над созданием единственного объекта/экземпляра возлагается на сам класс. Доступ к этому
объекту осуществляется через статическую функцию-члена класса, которая возвращает указатель или ссылку на него.

##### Пример
```cpp
#include <iostream>

class Singleton
{
    private:
        //здесь будет сохранен экземпляр
        static Singleton* instance;

        //скрытый конструктор для предотвращения создания экземпляров
        Singleton();

    public:
        //статический метод доступа, доступны без создания объекта класса
        static Singleton* getInstance();
};

// ноль, так как экземпляр будет инициализирован по требованию
Singleton* Singleton::instance = 0;

Singleton* Singleton::getInstance()
{
    if (instance == 0)
    {
        instance = new Singleton();
    }

    return instance;
}

Singleton::Singleton()
{}

int main()
{
    //new Singleton(); // Won't work
    Singleton* s = Singleton::getInstance(); // Ok
    Singleton* r = Singleton::getInstance();

    //адреса будут одинаковые
    std::cout << s << std::endl;
    std::cout << r << std::endl;
}
```
